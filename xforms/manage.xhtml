<?xml version="1.0" encoding="utf-8"?>
<html xmlns="http://www.w3.org/1999/xhtml" xmlns:xforms="http://www.w3.org/2002/xforms" xmlns:xs="http://www.w3.org/2001/XMLSchema"
	xmlns:ev="http://www.w3.org/2001/xml-events" xmlns:xxforms="http://orbeon.org/oxf/xml/xforms" xmlns:xi="http://www.w3.org/2001/XInclude"
	xmlns:fr="http://orbeon.org/oxf/xml/form-runner" xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#" xmlns:void="http://rdfs.org/ns/void#"
	xmlns:dcterms="http://purl.org/dc/terms/" xmlns:crm="http://www.cidoc-crm.org/cidoc-crm/" xmlns:nmo="http://nomisma.org/ontology#"
	xmlns:foaf="http://xmlns.com/foaf/0.1/" xmlns:res="http://www.w3.org/2005/sparql-results#" xmlns:edm="http://www.europeana.eu/schemas/edm/"
	xmlns:skos="http://www.w3.org/2004/02/skos/core#" xmlns:svcs="http://rdfs.org/sioc/services#" xmlns:doap="http://usefulinc.com/ns/doap#"
	xmlns:sd="http://www.w3.org/TR/sparql11-service-description/" xmlns:rdfs="http://www.w3.org/2000/01/rdf-schema#"
	xmlns:crmsci="http://www.ics.forth.gr/isl/CRMsci/" xmlns:crmgeo="http://www.ics.forth.gr/isl/CRMgeo/"
	xmlns:crmarchaeo="http://www.cidoc-crm.org/cidoc-crm/CRMarchaeo/" xmlns:geo="http://www.w3.org/2003/01/geo/wgs84_pos#">
	<head>
		<title>nomisma.org: manage datasets</title>
		<link rel="stylesheet" href="/fr/style/bootstrap/css/bootstrap.css" type="text/css" />
		<link rel="stylesheet" href="/fr/style/form-runner-bootstrap-override.css" type="text/css" />
		<link rel="shortcut icon" href="/ops/images/orbeon-icon-16.ico" />
		<link rel="icon" href="/ops/images/orbeon-icon-16.png" type="image/png" />
		<link rel="stylesheet" href="http://netdna.bootstrapcdn.com/bootstrap/3.3.6/css/bootstrap.min.css" />
		<script type="text/javascript" src="http://netdna.bootstrapcdn.com/bootstrap/3.3.6/js/bootstrap.min.js"></script>
		<link rel="stylesheet" href="/apps/nomisma/xforms/css/style.css" />

		<xforms:model>
			<!-- ***** RDF templates ***** -->
			<xforms:instance id="rdf" xxforms:exclude-result-prefixes="#default xhtml xforms xs ev xxforms fr res xi nomisma">
				<rdf:RDF xmlns="" xmlns:dcterms="http://purl.org/dc/terms/" xmlns:nm="http://nomisma.org/id/" xmlns:nmo="http://nomisma.org/ontology#"
					xmlns:foaf="http://xmlns.com/foaf/0.1/" xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
					xmlns:rdfs="http://www.w3.org/2000/01/rdf-schema#" xmlns:skos="http://www.w3.org/2004/02/skos/core#"
					xmlns:geo="http://www.w3.org/2003/01/geo/wgs84_pos#" xmlns:xsd="http://www.w3.org/2001/XMLSchema#"
					xmlns:un="http://www.owl-ontologies.com/Ontology1181490123.owl#" xmlns:edm="http://www.europeana.eu/schemas/edm/"
					xmlns:svcs="http://rdfs.org/sioc/services#" xmlns:doap="http://usefulinc.com/ns/doap#"/>
			</xforms:instance>

			<xforms:instance id="void-rdf" xxforms:exclude-result-prefixes="#default xhtml xforms xs ev xxforms fr res xi nomisma">
				<rdf:RDF xmlns="" xmlns:dcterms="http://purl.org/dc/terms/" xmlns:nm="http://nomisma.org/id/" xmlns:nmo="http://nomisma.org/ontology#"
					xmlns:foaf="http://xmlns.com/foaf/0.1/" xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
					xmlns:rdfs="http://www.w3.org/2000/01/rdf-schema#" xmlns:skos="http://www.w3.org/2004/02/skos/core#"
					xmlns:geo="http://www.w3.org/2003/01/geo/wgs84_pos#" xmlns:xsd="http://www.w3.org/2001/XMLSchema#"
					xmlns:un="http://www.owl-ontologies.com/Ontology1181490123.owl#" xmlns:edm="http://www.europeana.eu/schemas/edm/"
					xmlns:svcs="http://rdfs.org/sioc/services#" xmlns:doap="http://usefulinc.com/ns/doap#">
					<void:Dataset rdf:about="http://numismatics.org/search/">
						<dcterms:title xml:lang="en"/>
						<dcterms:description xml:lang="en"/>
						<dcterms:publisher rdf:resource=""/>
						<dcterms:license rdf:resource=""/>
						<void:dataDump rdf:resource="http://numismatics.org/collection/1944.100.76933.jsonld?profile=linkedart"/>
					</void:Dataset>
				</rdf:RDF>
			</xforms:instance>

			<xforms:instance id="places" xxforms:exclude-result-prefixes="#default xhtml xforms xs ev xxforms fr res xi nomisma">
				<rdf:RDF xmlns="" xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#" xmlns:void="http://rdfs.org/ns/void#"
					xmlns:foaf="http://xmlns.com/foaf/0.1/" xmlns:skos="http://www.w3.org/2004/02/skos/core#" xmlns:crm="http://www.cidoc-crm.org/cidoc-crm/"
					xmlns:edm="http://www.europeana.eu/schemas/edm/" xmlns:dcterms="http://purl.org/dc/terms/"
					xmlns:rdfs="http://www.w3.org/2000/01/rdf-schema#" xmlns:xsd="http://www.w3.org/2001/XMLSchema#"
					xmlns:crmsci="http://www.ics.forth.gr/isl/CRMsci/" xmlns:crmarchaeo="http://www.cidoc-crm.org/cidoc-crm/CRMarchaeo/"
					xmlns:crmgeo="http://www.ics.forth.gr/isl/CRMgeo/" xmlns:geo="http://www.w3.org/2003/01/geo/wgs84_pos#"/>
			</xforms:instance>

			<!-- RDF templates for harvesting -->
			<xforms:instance id="object" xxforms:exclude-result-prefixes="#all">
				<nmo:NumismaticObject xmlns="" rdf:about="" xmlns:dcterms="http://purl.org/dc/terms/" xmlns:nmo="http://nomisma.org/ontology#"
					xmlns:foaf="http://xmlns.com/foaf/0.1/" xmlns:edm="http://www.europeana.eu/schemas/edm/" xmlns:svcs="http://rdfs.org/sioc/services#"
					xmlns:doap="http://usefulinc.com/ns/doap#"> </nmo:NumismaticObject>
			</xforms:instance>

			<xforms:instance id="webresource-template" xxforms:exclude-result-prefixes="#all">
				<edm:WebResource rdf:about="">
					<svcs:has_service rdf:resource=""/>
					<dcterms:isReferencedBy rdf:resource=""/>
				</edm:WebResource>
			</xforms:instance>

			<xforms:instance id="service-template" xxforms:exclude-result-prefixes="#all">
				<svcs:Service rdf:about="">
					<dcterms:conformsTo rdf:resource="http://iiif.io/api/image"/>
					<doap:implements rdf:resource="http://iiif.io/api/image/2/level1.json"/>
				</svcs:Service>
			</xforms:instance>

			<!-- place names for findspot harvesting -->
			<xforms:instance id="place-template" xxforms:exclude-result-prefixes="#all">
				<crm:E53_Place rdf:about=""/>
			</xforms:instance>

			<xforms:instance id="spatialThing-template" xxforms:exclude-result-prefixes="#all">
				<crmgeo:SP5_Geometric_Place_Expression rdf:about="">
					<rdf:type rdf:resource="http://www.w3.org/2003/01/geo/wgs84_pos#SpatialThing"/>
					<crmgeo:Q9_is_expressed_in_terms_of rdf:resource="http://www.wikidata.org/entity/Q215848"/>
					<geo:lat rdf:datatype="http://www.w3.org/2001/XMLSchema#decimal"/>
					<geo:long rdf:datatype="http://www.w3.org/2001/XMLSchema#decimal"/>
					<crmgeo:asWKT rdf:datatype="http://www.opengis.net/ont/geosparql#wktLiteral"/>
				</crmgeo:SP5_Geometric_Place_Expression>
			</xforms:instance>

			<!-- errors or warnings -->
			<xforms:instance id="warnings" xxforms:exclude-result-prefixes="#all">
				<warnings xmlns=""></warnings>
			</xforms:instance>

			<xforms:instance id="errors" xxforms:exclude-result-prefixes="#all">
				<errors xmlns=""></errors>
			</xforms:instance>

			<!-- Concordance URIs -->
			<xforms:instance id="mappings" xxforms:exclude-result-prefixes="#all">
				<mappings xmlns=""></mappings>
			</xforms:instance>

			<!-- Matches made to findspots -->
			<xforms:instance id="findspot-matches" xxforms:exclude-result-prefixes="#all">
				<findspots xmlns=""></findspots>
			</xforms:instance>

			<!-- Linked Art JSON-LD instance -->
			<xforms:instance id="json" xxforms:exclude-result-prefixes="#all">
				<json></json>
			</xforms:instance>

			<!-- config and controls -->
			<xforms:instance id="config" xxforms:exclude-result-prefixes="#all">
				<xi:include href="../config.xml"/>
			</xforms:instance>

			<xforms:instance id="control-instance" xxforms:exclude-result-prefixes="#all">
				<controls xmlns="">
					<status></status>
					<void_uri></void_uri>
					<dump_uri></dump_uri>
					<mode>validate</mode>
					<dataset></dataset>
					<namedGraph>default</namedGraph>
					<license></license>
					<gazetteer_uri></gazetteer_uri>
					<validate-trigger>false</validate-trigger>
					<import-json-trigger>false</import-json-trigger>
					<import-dump-trigger>false</import-dump-trigger>
					<new_findspot_uri></new_findspot_uri>
					<concept_type></concept_type>
					<response></response>
					<object_count>0</object_count>
					<type_count>0</type_count>
					<hoard_count>0</hoard_count>
					<symbol_count>0</symbol_count>
				</controls>
			</xforms:instance>

			<xforms:instance id="languages">
				<xi:include href="instances/languages.xml"/>
			</xforms:instance>

			<xforms:instance id="rights">
				<xi:include href="instances/rights.xml"/>
			</xforms:instance>

			<xforms:instance id="licenses">
				<xi:include href="instances/licenses.xml"/>
			</xforms:instance>

			<!-- Wikidata properties -->
			<xforms:instance id="wikidata-properties" xxforms:exclude-result-prefixes="#all">
				<props xmlns="">
					<prop namespace="vocab.getty.edu">P1667</prop>
					<prop namespace="sws.geonames.org">P1566</prop>
					<prop namespace="data.ordnancesurvey.co.uk">P3120</prop>
					<prop namespace="pleiades.stoa.org">P1584</prop>
				</props>
			</xforms:instance>

			<!-- download CSV -->
			<xforms:instance id="csv" xxforms:exclude-result-prefixes="#all">
				<csv xmlns=""></csv>
			</xforms:instance>

			<xforms:instance id="csv-download" xxforms:exclude-result-prefixes="#all">
				<csv xmlns="" filename="places.csv" mediatype="text/csv"></csv>
			</xforms:instance>

			<!-- store the void:Datasets in their own instance to free up the SPARQL response for other data harvesting and validation -->
			<xforms:instance id="datasets">
				<rdf:RDF/>
			</xforms:instance>

			<xforms:instance id="namedGraphs">
				<rdf:RDF/>
			</xforms:instance>

			<xforms:instance id="collections" xxforms:exclude-result-prefixes="#all">
				<collections xmlns=""></collections>
			</xforms:instance>

			<!-- SPARQL instances -->
			<xforms:instance id="sparqlQuery">
				<query></query>
			</xforms:instance>

			<!-- preloaded instances -->
			<xforms:instance id="sparqlResponse">
				<sparql xmlns="http://www.w3.org/2005/sparql-results#"/>
			</xforms:instance>

			<!-- sparql update -->
			<xforms:instance id="sparqlUpdate-template">
				<templates xmlns="">
					<query id="delete-metadata"><![CDATA[PREFIX void:	<http://rdfs.org/ns/void#>
PREFIX sd:	<http://www.w3.org/TR/sparql11-service-description/>
DELETE {?s ?p ?o} WHERE {
	{<DATASET> sd:namedGraph ?s . ?s ?p ?o }
	UNION {<DATASET> ?p ?o . ?s ?p ?o . FILTER (?s = <DATASET>)}
}]]></query>
					<query id="delete-NumismaticObject"><![CDATA[PREFIX nmo:	<http://nomisma.org/ontology#>
PREFIX void:	<http://rdfs.org/ns/void#>
PREFIX dcterms:	<http://purl.org/dc/terms/>
PREFIX foaf:	<http://xmlns.com/foaf/0.1/>
PREFIX svcs:	<http://rdfs.org/sioc/services#>
PREFIX crm:	<http://www.cidoc-crm.org/cidoc-crm/>
DELETE {?s ?p ?o} WHERE {
{ ?object void:inDataset <DATASET> ;
  foaf:depiction ?image .
  ?image svcs:has_service ?s . ?s ?p ?o}
UNION { ?object void:inDataset <DATASET> ;
  foaf:depiction ?s . ?s ?p ?o}
UNION { ?object  void:inDataset <DATASET> ;
	nmo:hasObverse/foaf:depiction ?image .
  ?image svcs:has_service ?s . ?s ?p ?o}
UNION { ?object  void:inDataset <DATASET> ;
	nmo:hasObverse/foaf:depiction ?s . ?s ?p ?o}
UNION { ?object  void:inDataset <DATASET> ;
	nmo:hasObverse ?s . ?s ?p ?o}
UNION { ?object  void:inDataset <DATASET> ;
	nmo:hasReverse/foaf:depiction ?image .
  ?image svcs:has_service ?s . ?s ?p ?o}
UNION { ?object  void:inDataset <DATASET> ;
	nmo:hasReverse/foaf:depiction ?s . ?s ?p ?o}
UNION { ?object  void:inDataset <DATASET> ;
	nmo:hasReverse ?s . ?s ?p ?o}
UNION { ?object  void:inDataset <DATASET> ;
	nmo:hasFindspot/crm:P7_took_place_at ?s . ?s ?p ?o}
UNION { ?object  void:inDataset <DATASET> ;
	nmo:hasFindspot ?s . ?s ?p ?o}
UNION { ?s void:inDataset <DATASET> . ?s ?p ?o}
}]]></query>
					<query id="delete-TypeSeriesItem"><![CDATA[PREFIX nmo:	<http://nomisma.org/ontology#>
PREFIX void:	<http://rdfs.org/ns/void#>
PREFIX dcterms:	<http://purl.org/dc/terms/>
PREFIX foaf:	<http://xmlns.com/foaf/0.1/>
PREFIX svcs:	<http://rdfs.org/sioc/services#>
PREFIX skos:	<http://www.w3.org/2004/02/skos/core#>
PREFIX prov:	<http://www.w3.org/ns/prov#>
PREFIX crm:	<http://www.cidoc-crm.org/cidoc-crm/>
DELETE {?s ?p ?o} WHERE {
{ ?object void:inDataset <DATASET> ;
  skos:changeNote ?prov . 
  ?prov ?hasActivity ?s .
  ?s a prov:Activity . ?s ?p ?o}
UNION { ?object void:inDataset <DATASET> ;
  nmo:hasObverse|nmo:hasReverse|crm:P165i_is_incorporated_in|skos:changeNote ?s . ?s ?p ?o }
UNION { ?s void:inDataset <DATASET> . ?s ?p ?o}
}]]></query>
					<query id="delete-Hoard"><![CDATA[PREFIX nmo:	<http://nomisma.org/ontology#>
PREFIX void:	<http://rdfs.org/ns/void#>
PREFIX crm:	<http://www.cidoc-crm.org/cidoc-crm/>
PREFIX dcterms:	<http://purl.org/dc/terms/>
PREFIX foaf:	<http://xmlns.com/foaf/0.1/>
PREFIX svcs:	<http://rdfs.org/sioc/services#>
DELETE {?s ?p ?o} WHERE {
{ ?object void:inDataset <DATASET> ;
  nmo:hasFindspot/crm:P7_took_place_at ?s . ?s ?p ?o }
UNION { ?object void:inDataset <DATASET> ;
  dcterms:tableOfContents|nmo:hasFindspot ?s . ?s ?p ?o }
UNION { ?s void:inDataset <DATASET> . ?s ?p ?o}
}]]></query>
					<query id="delete-namedGraph"><![CDATA[DROP GRAPH <%GRAPH%>]]></query>
					<query id="replace-findspot"><![CDATA[PREFIX nmo:	<http://nomisma.org/ontology#>
PREFIX dcterms:	<http://purl.org/dc/terms/>
PREFIX foaf:	<http://xmlns.com/foaf/0.1/>
PREFIX geo:	<http://www.w3.org/2003/01/geo/wgs84_pos#>
PREFIX xsd:	<http://www.w3.org/2001/XMLSchema#>
DELETE DATA { 
  <URI> nmo:hasFindspot <OLDFINDSPOT>
} ;
INSERT DATA {
  <URI> nmo:hasFindspot <NEWFINDSPOT> .
  <NEWFINDSPOT> geo:lat "LAT"^^xsd:decimal; 
  		geo:long "LONG"^^xsd:decimal;
  		foaf:name "NAME";
  		dcterms:isPartOf <OLDFINDSPOT>
}]]></query>
					<query id="revert-findspot"><![CDATA[PREFIX nmo:	<http://nomisma.org/ontology#>
PREFIX dcterms:	<http://purl.org/dc/terms/>
PREFIX foaf:	<http://xmlns.com/foaf/0.1/>
PREFIX geo:	<http://www.w3.org/2003/01/geo/wgs84_pos#>
PREFIX xsd:	<http://www.w3.org/2001/XMLSchema#>
DELETE DATA { 
  <URI> nmo:hasFindspot <OLDFINDSPOT>
} ;
INSERT DATA {
  <URI> nmo:hasFindspot <NEWFINDSPOT> 
}]]></query>
					<query id="insert-test-findspot"><![CDATA[PREFIX nmo:	<http://nomisma.org/ontology#>
PREFIX dcterms:	<http://purl.org/dc/terms/>
PREFIX foaf:	<http://xmlns.com/foaf/0.1/>
PREFIX geo:	<http://www.w3.org/2003/01/geo/wgs84_pos#>
PREFIX xsd:	<http://www.w3.org/2001/XMLSchema#>
INSERT DATA
{
  <URI> nmo:hasFindspot <FINDSPOT> .
  <FINDSPOT> geo:lat "LAT"^^xsd:decimal; 
  		geo:long "LONG"^^xsd:decimal;
  		foaf:name "NAME"
}]]></query>
				</templates>
			</xforms:instance>

			<xforms:instance id="sparqlUpdate">
				<query></query>
			</xforms:instance>

			<!-- sparql query templates -->
			<xforms:instance id="sparql-templates">
				<templates xmlns="">
					<query id="get-datasets"><![CDATA[PREFIX rdf:	<http://www.w3.org/1999/02/22-rdf-syntax-ns#>
PREFIX dcterms:	<http://purl.org/dc/terms/>
PREFIX void:	<http://rdfs.org/ns/void#>
PREFIX skos:	<http://www.w3.org/2004/02/skos/core#>
CONSTRUCT {?uri rdf:type void:Dataset ; 
  dcterms:publisher ?publisher; 
  dcterms:title ?title ; 
  void:dataDump ?dump ;
  dcterms:type ?type }
WHERE {   
  ?uri a void:Dataset ; 
  	void:dataDump ?dump ; 
  	dcterms:publisher | dcterms:publisher/skos:prefLabel ?publisher FILTER (isLiteral(?publisher)) .
  ?uri dcterms:title ?title FILTER (lang(?title) = "" || langMatches(lang(?title), "en")).
  { SELECT DISTINCT ?uri ?type WHERE {
      ?coins void:inDataset ?uri ;
             rdf:type ?type
    } GROUP BY ?uri ?type
  }
} ORDER BY ASC(?publisher) ASC(?title)]]></query>
					<query id="get-namedGraphs"><![CDATA[PREFIX rdf:	<http://www.w3.org/1999/02/22-rdf-syntax-ns#>
PREFIX dcterms:	<http://purl.org/dc/terms/>
PREFIX void:	<http://rdfs.org/ns/void#>
PREFIX skos:	<http://www.w3.org/2004/02/skos/core#>
PREFIX sd:	<http://www.w3.org/TR/sparql11-service-description/>
CONSTRUCT {?uri rdf:type void:Dataset ; 
  dcterms:publisher ?publisher; 
  dcterms:title ?title ; 
  void:dataDump ?dump ;
  dcterms:type ?type ;
  sd:namedGraph ?namedGraph}
WHERE {   
  {?uri a sd:Dataset}
  UNION {?uri a void:Dataset}
  ?uri void:dataDump ?dump ; 
  	dcterms:publisher | dcterms:publisher/skos:prefLabel ?publisher FILTER (isLiteral(?publisher)) .
  ?uri dcterms:title ?title FILTER (lang(?title) = "" || langMatches(lang(?title), "en")).
  ?uri sd:namedGraph/sd:name ?namedGraph
  OPTIONAL {?uri dcterms:type ?type }
} ORDER BY ASC(?publisher) ASC(?title)]]></query>
					<query id="get-collections"><![CDATA[PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>
PREFIX skos: <http://www.w3.org/2004/02/skos/core#>
PREFIX nmo:	<http://nomisma.org/ontology#>
SELECT ?uri ?label WHERE {
  ?uri a nmo:Collection ;
       skos:prefLabel ?label FILTER (langMatches(lang(?label), "en"))
} ORDER BY ASC(?label)]]></query>
					<query id="get-match"><![CDATA[PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>
PREFIX skos: <http://www.w3.org/2004/02/skos/core#>
SELECT ?uri ?type WHERE {
  ?uri skos:exactMatch <%MATCH%> ;
       rdf:type ?type FILTER (?type != skos:Concept)
}]]></query>
					<query id="ask-wikidata-match"><![CDATA[PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>
PREFIX skos: <http://www.w3.org/2004/02/skos/core#>
ASK {
  <%MATCH%> skos:inScheme <http://www.wikidata.org/entity/>
}]]></query>
					<query id="get-wikidata-match"><![CDATA[PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>
PREFIX skos: <http://www.w3.org/2004/02/skos/core#>
SELECT ?uri WHERE {
  ?uri skos:closeMatch <%MATCH%> ;
       skos:inScheme <http://www.wikidata.org/entity/>
}]]></query>
					<query id="query-wikidata-match"><![CDATA[CONSTRUCT {
  ?place a skos:Concept; 
  		   rdfs:label ?placeLabel;
           skos:closeMatch ?osgeo;
           skos:closeMatch ?tgn;
           skos:closeMatch ?geonames ;
           skos:closeMatch ?pleiades ; 
           skos:broader ?parent ;
           dct:coverage ?coord ;
           dct:type ?type .
}
WHERE {
  %STATEMENT% .
  OPTIONAL {?place wdt:P3120 ?osgeoid .
  	BIND (uri(concat("http://data.ordnancesurvey.co.uk/id/", ?osgeoid)) as ?osgeo)}
  OPTIONAL {?place wdt:P1667 ?tgnid .
  	BIND (uri(concat("http://vocab.getty.edu/tgn/", ?tgnid)) as ?tgn)}
  OPTIONAL {?place wdt:P1566 ?geonamesid .
  	BIND (uri(concat("https://sws.geonames.org/", ?geonamesid, "/")) as ?geonames)}
  OPTIONAL {?place wdt:P1584 ?pleiadesid .
  	BIND (uri(concat("https://pleiades.stoa.org/places/", ?pleiadesid)) as ?pleiades)}
  OPTIONAL {?place p:P625/ps:P625 ?coord}
  OPTIONAL {?place wdt:P131 ?parent}
  OPTIONAL {?place wdt:P31/wdt:P279+|wdt:P31 ?type . FILTER (?type = wd:Q486972)} #is human settlement
  OPTIONAL {?place wdt:P31 ?type FILTER (?type = wd:Q839954)} #archaeological site
  SERVICE wikibase:label {
	bd:serviceParam wikibase:language "en"
  }
}]]></query>
				</templates>
			</xforms:instance>

			<!-- ************* BINDINGS **********************-->
			<xforms:bind nodeset="instance('void-rdf')">
				<xforms:bind nodeset="void:Dataset">
					<xforms:bind nodeset="@rdf:about" required="true()" type="xs:anyURI" constraint="matches(., 'https?://(-\.)?([^\s/?\.#]+\.?)+(/[^\s]*)?$')"/>
					<xforms:bind nodeset="dcterms:title" required="true()">
						<xforms:bind nodeset="@xml:lang"
							constraint="string-length(.) &gt; 0 and (count(parent::node()/parent::node()/dcterms:title/@xml:lang) = count(distinct-values(parent::node()/parent::node()/dcterms:title/@xml:lang)))"
						/>
					</xforms:bind>
					<xforms:bind nodeset="dcterms:description" required="true()">
						<xforms:bind nodeset="@xml:lang"
							constraint="string-length(.) &gt; 0 and (count(parent::node()/parent::node()/dcterms:description/@xml:lang) = count(distinct-values(parent::node()/parent::node()/dcterms:description/@xml:lang)))"
						/>
					</xforms:bind>
					<xforms:bind nodeset="dcterms:license"
						constraint="if (not(@rdf:resource)) then string-length(normalize-space(.)) &gt; 0 else string-length(normalize-space(.)) = 0"/>
					<xforms:bind nodeset="dcterms:rights"
						constraint="if (not(@rdf:resource)) then string-length(normalize-space(.)) &gt; 0 else string-length(normalize-space(.)) = 0"/>
					<xforms:bind nodeset="//@rdf:resource" type="xs:anyURI" required="true()"
						constraint="matches(., 'https?://(-\.)?([^\s/?\.#]+\.?)+(/[^\s]*)?$')"/>
				</xforms:bind>
			</xforms:bind>

			<xforms:bind nodeset="instance('control-instance')">
				<xforms:bind id="validate-trigger" nodeset="validate-trigger" type="xs:boolean" readonly=". != true()"/>
				<xforms:bind id="import-json-trigger" nodeset="import-json-trigger" type="xs:boolean" readonly=". != true()"/>
				<xforms:bind id="import-dump-trigger" nodeset="import-dump-trigger" type="xs:boolean" readonly=". != true()"/>
				<xforms:bind nodeset="license" required="true()">
					<xforms:bind nodeset="@other" required="true()"/>
				</xforms:bind>
				<xforms:bind nodeset="rights" required="true()">
					<xforms:bind nodeset="@other" required="true()"/>
				</xforms:bind>
				<xforms:bind nodeset="object_count" type="xs:integer"/>
				<xforms:bind nodeset="type_count" type="xs:integer"/>
				<xforms:bind nodeset="hoard_count" type="xs:integer"/>
				<xforms:bind nodeset="symbol_count" type="xs:integer"/>
			</xforms:bind>

			<xforms:bind nodeset="instance('csv-download')" type="xs:base64Binary"/>

			<!-- **************** DYNAMIC VALIDATION CONTROLS ********************** -->
			<xforms:action ev:event="xxforms-invalid" ev:observer="void-rdf">
				<xforms:setvalue ref="instance('control-instance')/import-json-trigger" value="false()"/>
			</xforms:action>

			<xforms:action ev:event="xxforms-valid" ev:observer="void-rdf">
				<xforms:setvalue ref="instance('control-instance')/import-json-trigger" value="true()"/>
			</xforms:action>

			<!-- ************* SPARQL SUBMISSIONS **********************-->
			<xforms:submission id="submit-sparqlQuery" action="{instance('config')/sparql_query}?query={encode-for-uri(instance('sparqlQuery'))}&amp;output=xml"
				ref="instance('sparqlResponse')" replace="instance" method="get">
				<xforms:message ev:event="xforms-submit-error" level="modal">SPARQL query failed.</xforms:message>
			</xforms:submission>

			<xforms:submission id="update-graph" action="{instance('config')/sparql_update}" ref="instance('sparqlUpdate')" serialization="text/plain"
				replace="none" method="post" mediatype="application/sparql-update">
				<xforms:setvalue ev:event="xforms-submit-done" ref="instance('control-instance')/status">Graph successfully deleted from
					endpoint.</xforms:setvalue>
				<xforms:message ev:event="xforms-submit-error" level="modal">SPARQL update failed.</xforms:message>
			</xforms:submission>

			<xforms:submission id="post-void" action="{instance('config')/sparql_store}?default" ref="instance('void-rdf')" replace="none" method="post"
				mediatype="application/rdf+xml">
				<xforms:setvalue ev:event="xforms-submit-done" ref="instance('control-instance')/status">Successfully posted to endpoint.</xforms:setvalue>
				<xforms:message ev:event="xforms-submit-error" level="modal">Unable to post VoID metadata.</xforms:message>
			</xforms:submission>

			<xforms:submission id="post-dump" action="{instance('config')/sparql_store}?graph={instance('control-instance')/namedGraph}" ref="instance('rdf')"
				replace="none" method="post" mediatype="application/rdf+xml">
				<xforms:setvalue ev:event="xforms-submit-done" ref="instance('control-instance')/status">Successfully posted to endpoint.</xforms:setvalue>
				<xforms:message ev:event="xforms-submit-error" level="modal">Unable to post data dump.</xforms:message>
			</xforms:submission>

			<xforms:submission id="post-places" action="{instance('config')/sparql_store}?default" ref="instance('places')" replace="none" method="post"
				mediatype="application/rdf+xml">
				<xforms:setvalue ev:event="xforms-submit-done" ref="instance('control-instance')/status">Successfully posted places to
					endpoint.</xforms:setvalue>
				<xforms:message ev:event="xforms-submit-error" level="modal">Unable to post places RDF.</xforms:message>
			</xforms:submission>

			<!-- ************************* SOLR SUBMISSIONS ************************** -->
			<xforms:submission id="post-solr-doc" action="{instance('config')/solr_fuseki}update" ref="instance('addIndex')" instance="addIndex" replace="none"
				method="post">
				<xforms:message ev:event="xforms-submit-error" level="modal">Data Failed to POST to Solr. Index may be offline or URL is
					incorrect.</xforms:message>
				<xforms:send submission="submit-commit" ev:event="xforms-submit-done"/>
			</xforms:submission>

			<xforms:submission id="submit-commit" action="{instance('config')/solr_fuseki}update" ref="instance('sendCommit')" instance="sendCommit"
				replace="none" method="post">
				<xforms:message level="modal" ev:event="xforms-submit-error">Failed to commit to Solr index.</xforms:message>
			</xforms:submission>

			<!-- ************************* LOAD RDF/XML ************************** -->
			<xforms:submission id="load-void" serialization="application/xml" method="get" action="{instance('control-instance')/void_uri}" replace="instance"
				instance="void-rdf">
				<xforms:header>
					<xforms:name>User-Agent</xforms:name>
					<xforms:value>XForms/Nomisma.org</xforms:value>
				</xforms:header>

				<xforms:action ev:event="xforms-submit-error">
					<!-- if the mime-type is not a type of XML, then check to see if the event('body') is RDF (an application/octet-stream attachment from ContentDM) -->
					<xforms:action if="event('body')/*/namespace-uri() = 'http://www.w3.org/1999/02/22-rdf-syntax-ns#'">
						<!-- delete the void:Dataset and insert the new one from the response body -->
						<xforms:delete nodeset="instance('void-rdf')/void:Dataset"/>

						<xforms:insert context="instance('void-rdf')" origin="event('body')/rdf:RDF/void:Dataset"/>
					</xforms:action>
					<xforms:action if="not(event('body')/*/namespace-uri() = 'http://www.w3.org/1999/02/22-rdf-syntax-ns#')">
						<xforms:message level="modal">Unable to load VoID metadata RDF.</xforms:message>
					</xforms:action>
				</xforms:action>
			</xforms:submission>

			<xforms:submission id="load-dump" serialization="none" method="get" action="{instance('control-instance')/dump_uri}" replace="instance"
				instance="rdf">
				<xforms:header>
					<xforms:name>User-Agent</xforms:name>
					<xforms:value>XForms/Nomisma.org</xforms:value>
				</xforms:header>

				<xforms:action ev:event="xforms-submit-error">
					<!-- if the mime-type is not a type of XML, then check to see if the event('body') is RDF (an application/octet-stream attachment from ContentDM) -->
					<xforms:action if="event('body')/*/namespace-uri() = 'http://www.w3.org/1999/02/22-rdf-syntax-ns#'">
						<xforms:insert context="instance('rdf')" origin="event('body')/rdf:RDF/*"/>
					</xforms:action>
					<xforms:action if="not(event('body')/*/namespace-uri() = 'http://www.w3.org/1999/02/22-rdf-syntax-ns#')">
						<xforms:message level="modal">Unable to load VoID dump.</xforms:message>
					</xforms:action>
				</xforms:action>

				<xforms:action ev:event="xforms-submit-done">
					<!-- evaluate the findspot URIs and align them with Wikidata -->
					<xforms:action if="instance('control-instance')/mode = 'validate'">

						<!-- set instance counts for report -->
						<xforms:setvalue ref="instance('control-instance')/object_count"
							value="instance('control-instance')/object_count + count(instance('rdf')//nmo:NumismaticObject)"/>
						<xforms:setvalue ref="instance('control-instance')/type_count"
							value="instance('control-instance')/type_count + count(instance('rdf')//nmo:TypeSeriesItem)"/>
						<xforms:setvalue ref="instance('control-instance')/hoard_count"
							value="instance('control-instance')/hoard_count + count(instance('rdf')//nmo:Hoard)"/>
						<xforms:setvalue ref="instance('control-instance')/symbol_count"
							value="instance('control-instance')/symbol_count + count(instance('rdf')//nmo:Monogram) + count(instance('rdf')//crm:E37_Mark)"/>

						<xforms:action
							xxforms:iterate="distinct-values(instance('rdf')//nmo:hasFindspot/descendant::crm:P89_falls_within/@rdf:resource)[position() &lt; 25]">
							<xforms:var name="uri" select="."/>
							<xforms:setvalue ref="instance('control-instance')/gazetteer_uri" value="$uri"/>

							<!-- only parse gazetteer URIs from Getty TGN, Wikidata, Geonames, Ordnance Survey, or Pleiades -->
							<xforms:action
								if="matches($uri, 'https?://') and (contains($uri, 'vocab.getty.edu/tgn/') or contains($uri, 'wikidata.org') or contains($uri, 'sws.geonames.org') or contains($uri, 'data.ordnancesurvey.co.uk') or contains($uri, 'pleiades.stoa.org'))">

								<!-- if the findspot URI is not found in the matches instances, then execute a SPARQL query to see if the Place exists 
								in the Nomisma SPARQL endpoint already -->
								<xforms:action if="not(instance('findspot-matches')/findspot = $uri)">

									<!-- evaluate the URI to determine which SPARQL query to submit -->
									<xforms:setvalue ref="instance('sparqlQuery')"
										value="replace(instance('sparql-templates')/query[@id='ask-wikidata-match'], '%MATCH%', $uri)"
										if="matches($uri, '^http://www.wikidata.org/entity/Q[0-9]+$')"/>
									<xforms:setvalue ref="instance('sparqlQuery')"
										value="replace(instance('sparql-templates')/query[@id='get-wikidata-match'], '%MATCH%', $uri)"
										if="not(matches($uri, '^http://www.wikidata.org/entity/Q[0-9]+$'))"/>
									<xforms:send submission="submit-sparqlQuery"/>

									<!-- if the URI is in the Nomisma.org SPARQL endpoint, add it to the findspot-matches instance -->
									<xforms:action if="count(instance('sparqlResponse')//res:result) &gt; 0">
										<xforms:insert context="instance('findspot-matches')" nodeset="./child::node()[last()]"
											origin="xforms:element('findspot', (xforms:attribute('matches', instance('sparqlResponse')//res:result[1]/res:binding[@name='uri']/res:uri), $uri))"
										/>
									</xforms:action>

									<xforms:action if="instance('sparqlResponse')//res:boolean = true()">
										<xforms:insert context="instance('findspot-matches')" nodeset="./child::node()[last()]"
											origin="xforms:element('findspot', $uri)"/>
									</xforms:action>

									<!-- if the URI isn't in the Nomisma.org SPARQL endpoint, then execute Wikidata SPARQL queries to generate E53_Place nodes, coordinates, and hierarchy -->
									<xforms:action
										if="(not(matches($uri, '^http://www.wikidata.org/entity/Q[0-9]+$')) and count(instance('sparqlResponse')//res:result) = 0) or
										(matches($uri, '^http://www.wikidata.org/entity/Q[0-9]+$') and instance('sparqlResponse')//res:boolean = false())">

										<xforms:var name="id"
											select="if (contains($uri, 'sws.geonames.org')) then tokenize($uri, '/')[last() - 1] else tokenize($uri, '/')[last()]"/>
										<xforms:var name="namespace" select="tokenize($uri, '/')[3]"/>
										<xforms:var name="prop" select="instance('wikidata-properties')/prop[@namespace = $namespace]"/>

										<!-- set the SPARQL query, depending on URI -->
										<xforms:setvalue ref="instance('sparqlQuery')"
											value="replace(instance('sparql-templates')/query[@id='query-wikidata-match'], '%STATEMENT%', concat('?place wdt:', $prop, ' &#x022;', $id, '&#x022;'))"
											if="not(matches($uri, '^http://www.wikidata.org/entity/Q[0-9]+$'))"/>
										<xforms:setvalue ref="instance('sparqlQuery')"
											value="replace(instance('sparql-templates')/query[@id='query-wikidata-match'], '%STATEMENT%', concat('BIND (wd:', $id, ' as ?place)'))"
											if="matches($uri, '^http://www.wikidata.org/entity/Q[0-9]+$')"/>
										<xforms:send submission="query-wikidata"/>
									</xforms:action>
								</xforms:action>
							</xforms:action>
						</xforms:action>
					</xforms:action>
					<xforms:action if="instance('control-instance')/mode = 'import'">
						<!-- after the RDF dump is loaded and the findspot places have been reconciled to Wikidata, then replace
														non Wikidata URIs associated with findspots -->
						<xforms:action xxforms:iterate="instance('rdf')//nmo:hasFindspot/descendant::crm:P89_falls_within">
							<xforms:var name="uri" select="context()/@rdf:resource"/>

							<xforms:action
								if="matches($uri, 'https?://') and (contains($uri, 'vocab.getty.edu/tgn/') or contains($uri, 'sws.geonames.org') or contains($uri, 'data.ordnancesurvey.co.uk') or contains($uri, 'pleiades.stoa.org'))">

								<xforms:setvalue ref="context()/@rdf:resource" value="instance('findspot-matches')/findspot[. = $uri]/@matches"
									if="instance('findspot-matches')/findspot[. = $uri]/@matches"/>
							</xforms:action>
						</xforms:action>
					</xforms:action>
				</xforms:action>
			</xforms:submission>

			<!-- ************************* QUERY WIKIDATA SPARQL ENDPOINT ************************** -->
			<xforms:submission id="query-wikidata" action="https://query.wikidata.org/sparql?query={encode-for-uri(instance('sparqlQuery'))}"
				ref="instance('sparqlResponse')" replace="instance" method="get">
				<xforms:header>
					<xforms:name>Accept</xforms:name>
					<xforms:value>application/rdf+xml</xforms:value>
				</xforms:header>
				<xforms:header>
					<xforms:name>User-Agent</xforms:name>
					<xforms:value>XForms/Nomisma.org</xforms:value>
				</xforms:header>
				<xforms:message ev:event="xforms-submit-error" level="modal">Wikidata SPARQL query failed.</xforms:message>

				<!-- after a query is sent to Wikidata, write the resulting RDF from Wikidata into the Nomisma ingest -->
				<xforms:action ev:event="xforms-submit-done">
					<xforms:var name="q-valid" select="if (count(instance('sparqlResponse')/rdf:Description) = 1) then true() else false()"/>

					<!-- MATCH FOUND IN WIKIDATA: 
										if there is a resulting Q Entity in Wikidata, then insert the findspot into the matches instance and 
										generate subsquent place nodes in the Nomisma SPARQL endpoint -->
					<xforms:action if="$q-valid = true()">
						<xforms:var name="q_entity" select="data(instance('sparqlResponse')/rdf:Description/@rdf:about)"/>

						<xforms:action
							if="not(instance('findspot-matches')/findspot = $q_entity) and not(instance('findspot-matches')/findspot[@matches = $q_entity])">

							<!-- insert E53_Place and set related metadata -->
							<xforms:insert context="instance('places')" nodeset="./child::node()[last()]" origin="instance('place-template')"/>
							<xforms:setvalue ref="instance('places')/crm:E53_Place[last()]/@rdf:about" value="$q_entity"/>
							<xforms:insert context="instance('places')/crm:E53_Place[@rdf:about = $q_entity]" nodeset="./child::node()[last()]"
								origin="instance('sparqlResponse')//skos:closeMatch"/>
							<xforms:insert context="instance('places')/crm:E53_Place[@rdf:about = $q_entity]" nodeset="./child::node()[last()]"
								origin="xforms:element('rdfs:label', data(instance('sparqlResponse')//rdfs:label[1]))"/>
							<xforms:insert context="instance('places')/crm:E53_Place[@rdf:about = $q_entity]" nodeset="./child::node()[last()]"
								origin="xforms:element('skos:inScheme', xforms:attribute('rdf:resource', 'http://www.wikidata.org/entity/'))"/>

							<!-- reset value of Geonames to append forward slash because Wikidata SPARQL will not concatenate it -->
							<xforms:setvalue
								ref="instance('places')/crm:E53_Place[@rdf:about = $q_entity]/skos:closeMatch[contains(@rdf:resource, 'sws.geonames.org')]/@rdf:resource"
								value="concat(instance('places')/crm:E53_Place[@rdf:about = $q_entity]/skos:closeMatch[contains(@rdf:resource, 'sws.geonames.org')]/@rdf:resource, '/')"
								if="not(ends-with(instance('places')/crm:E53_Place[@rdf:about = $q_entity]/skos:closeMatch[contains(@rdf:resource, 'sws.geonames.org')]/@rdf:resource, '/'))"/>

							<!-- if there are coordinates and the place has a subtype of human settlement/archaeological site, insert the geo: and crm: properties and the spatialThing template -->
							<xforms:action
								if="instance('sparqlResponse')/rdf:Description/dcterms:coverage and instance('sparqlResponse')/rdf:Description/dcterms:type">
								<xforms:var name="geoURI" select="concat($q_entity, '#this')"/>
								<xforms:var name="coords" select="instance('sparqlResponse')/rdf:Description/dcterms:coverage[1]"/>

								<xforms:insert context="instance('places')/crm:E53_Place[@rdf:about = $q_entity]" nodeset="./child::node()[last()]"
									origin="xforms:element('geo:location', xforms:attribute('rdf:resource', $geoURI))"/>
								<xforms:insert context="instance('places')/crm:E53_Place[@rdf:about = $q_entity]" nodeset="./child::node()[last()]"
									origin="xforms:element('crm:P168_place_is_defined_by', xforms:attribute('rdf:resource', $geoURI))"/>

								<!-- set geo: and crmgeo: properties -->
								<xforms:insert context="instance('places')" nodeset="./child::node()[last()]" origin="instance('spatialThing-template')"/>
								<xforms:setvalue ref="instance('places')/crmgeo:SP5_Geometric_Place_Expression[last()]/@rdf:about" value="$geoURI"/>
								<xforms:setvalue ref="instance('places')/crmgeo:SP5_Geometric_Place_Expression[last()]/crmgeo:asWKT" value="$coords"/>
								<xforms:setvalue ref="instance('places')/crmgeo:SP5_Geometric_Place_Expression[last()]/geo:long"
									value="tokenize(substring-before(substring-after($coords, '('), ')'), ' ')[1]"/>
								<xforms:setvalue ref="instance('places')/crmgeo:SP5_Geometric_Place_Expression[last()]/geo:lat"
									value="tokenize(substring-before(substring-after($coords, '('), ')'), ' ')[2]"/>
							</xforms:action>

							<!-- perform a hierarchical Wikidata SPARQL query in order to generate E53_Places for each parent of the Q entity -->
							<xforms:action xxforms:iterate="instance('sparqlResponse')//skos:broader">
								<xforms:var name="parentURI" select="data(@rdf:resource)"/>

								<xforms:insert context="instance('places')/crm:E53_Place[@rdf:about = $q_entity]" nodeset="./child::node()[last()]"
									origin="xforms:element('crm:P89_falls_within', xforms:attribute('rdf:resource', $parentURI))"/>

								<!-- only execute Wikidata SPARQL query for a parent URI if it isn't already in the places RDF instance -->
								<xforms:action if="not(instance('places')/crm:E53_Place[@rdf:about = $parentURI])">
									<xforms:setvalue ref="instance('sparqlQuery')"
										value="replace(instance('sparql-templates')/query[@id='query-wikidata-match'], '%STATEMENT%', concat('BIND (wd:', tokenize($parentURI, '/')[last()], ' as ?place)'))"
										if="matches($parentURI, '^http://www.wikidata.org/entity/Q[0-9]+$')"/>

									<xforms:send submission="query-wikidata"/>
								</xforms:action>
							</xforms:action>
						</xforms:action>

						<!-- insert findspot concordance into matches instance to prevent further lookups for this URI -->
						<xforms:insert context="instance('findspot-matches')" nodeset="./child::node()[last()]" origin="xforms:element('findspot', $q_entity)"
							if="$q_entity = instance('control-instance')/gazetteer_uri"/>
						<xforms:insert context="instance('findspot-matches')" nodeset="./child::node()[last()]"
							origin="xforms:element('findspot', (xforms:attribute('matches', $q_entity), data(instance('control-instance')/gazetteer_uri)))"
							if="not($q_entity = instance('control-instance')/gazetteer_uri)"/>

					</xforms:action>

					<!-- MATCH NOT FOUND IN WIKIDATA: 
										if the matching URI is not found, then insert an error about the lack of a match to Wikidata -->
					<xforms:action if="$q-valid = false()">
						<xforms:insert context="instance('warnings')" nodeset="./child::node()[last()]"
							origin="xforms:element('warning', (xforms:attribute('uri', instance('control-instance')/gazetteer_uri), 
							xforms:attribute('label', data(instance('rdf')//crm:E53_Place[@rdf:about = instance('control-instance')/gazetteer_uri]/rdfs:label))))"/>

						<!-- insert the findspot URI into the instance('findspot-matches') to prevent additional lookups -->
						<xforms:insert context="instance('findspot-matches')" nodeset="./child::node()[last()]"
							origin="xforms:element('findspot', data(instance('control-instance')/gazetteer_uri))"/>

						<!-- if a place of this URI exists in the dump, move it to the places instance -->
						<xforms:action if="instance('rdf')//crm:E53_Place[@rdf:about = instance('control-instance')/gazetteer_uri]">
							<xforms:var name="spatial-uri"
								select="instance('rdf')//crm:E53_Place[@rdf:about = instance('control-instance')/gazetteer_uri]/geo:location/@rdf:resource"/>

							<xforms:insert context="instance('places')" nodeset="./child::node()[last()]"
								origin="instance('rdf')//crm:E53_Place[@rdf:about = instance('control-instance')/gazetteer_uri]"/>
							<xforms:insert context="instance('places')" nodeset="./child::node()[last()]" origin="instance('rdf')//*[@rdf:about = $spatial-uri]"/>

							<!-- set the concept scheme -->
							<xforms:insert context="instance('places')/crm:E53_Place[@rdf:about = instance('control-instance')/gazetteer_uri]"
								nodeset="./child::node()[last()]"
								origin="xforms:element('skos:inScheme', xforms:attribute('rdf:resource', concat(tokenize(instance('control-instance')/gazetteer_uri, '/')[1], '://', tokenize(instance('control-instance')/gazetteer_uri, '/')[3], '/')))"/>

							<!-- then delete the above objects from the RDF dump -->
							<xforms:delete nodeset="instance('rdf')//crm:E53_Place[@rdf:about = instance('control-instance')/gazetteer_uri]"/>
							<xforms:delete nodeset="instance('rdf')//*[@rdf:about = $spatial-uri]"/>
						</xforms:action>
					</xforms:action>
				</xforms:action>

			</xforms:submission>

			<!-- ************************* LOAD LINKED ART JSON-LD ************************** -->
			<xforms:submission id="load-json" serialization="none" method="get" action="{instance('void-rdf')/void:Dataset/void:dataDump/@rdf:resource}"
				replace="instance" instance="json">
				<xforms:action ev:event="xforms-submit-error">
					<xforms:message level="modal">Unable to load JSON-LD. Either it is not JSON or the URL is incorrect.</xforms:message>
				</xforms:action>

				<!-- iterate through each JSON Human-Made-Object at the level of each API call -->
				<xforms:action ev:event="xforms-submit-done">
					<!-- iterate through all id elements in order to convert Getty curies into full URIs -->
					<xforms:action xxforms:iterate="instance('json')//id">
						<xforms:var name="val" select="normalize-space(data(context()))"/>
						<xforms:var name="uri"
							select="if (starts-with($val, 'aat:') or starts-with($val, 'ulan:') or starts-with($val, 'tgn:')) then concat('http://vocab.getty.edu/', substring-before($val, ':'), '/', substring-after($val, ':'))
							else if (starts-with($val, 'nm:')) then concat('http://nomisma.org/id/', substring-after($val, ':')) else $val"/>

						<xforms:setvalue ref="context()" value="$uri"/>
					</xforms:action>

					<!-- extract all possible URIs and execute SPARQL queries to get their Nomisma.org exactMatch, if applicable -->
					<xforms:action xxforms:iterate="distinct-values(instance('json')//current_owner/id)">
						<xforms:var name="uri" select="normalize-space(data(context()))"/>

						<!-- perform lookup only if the URI hasn't already been mapped (applicable for eventual API pagination) -->
						<xforms:action if="not(instance('mappings')/mapping[@from = $uri]/@to)">
							<!-- set the SPARQL query-->
							<xforms:setvalue ref="instance('sparqlQuery')" value="replace(instance('sparql-templates')/query[@id='get-match'], '%MATCH%', $uri)"/>
							<xforms:send submission="submit-sparqlQuery"/>

							<!-- if there's a response, then insert the corresponding Nomisma URI and class -->
							<xforms:action if="instance('sparqlResponse')//res:result">
								<xforms:insert context="instance('mappings')" nodeset="./child::node()[last()]"
									origin="xforms:element('mapping', (xforms:attribute('from', $uri), xforms:attribute('to', instance('sparqlResponse')//res:binding[@name='uri']/res:uri), xforms:attribute('type', instance('sparqlResponse')//res:binding[@name='type']/res:uri)))"
								/>
							</xforms:action>
							<!-- otherwise insert a mapping @from without a @to to prevent further HTTP requests -->
							<xforms:action if="not(instance('sparqlResponse')//res:result)">
								<xforms:insert context="instance('mappings')" nodeset="./child::node()[last()]"
									origin="xforms:element('mapping', (xforms:attribute('from', $uri)))"/>
							</xforms:action>
						</xforms:action>
					</xforms:action>

					<!-- interate through all HMOs in the JSON-LD response that are not sides of a coin -->
					<xforms:action xxforms:iterate="instance('json')/descendant-or-self::node()[type='HumanMadeObject' and not(ancestor::part)]">
						<!-- use the home page link when available, otherwise use the URI for the HMO -->
						<xforms:var name="objectURI"
							select="if (context()/subject_of/_[classified_as/_/id = 'http://vocab.getty.edu/aat/300266277'])
							then context()/subject_of/_[classified_as/_/id = 'http://vocab.getty.edu/aat/300266277']/id else context()/id"/>

						<xforms:setvalue ref="instance('object')/@rdf:about" value="$objectURI"/>

						<!-- Identifiers: Title and Accession number -->
						<xforms:action xxforms:iterate="context()/identified_by/_">
							<xforms:var name="content" select="data(context()/content)"/>

							<xforms:action if="context()/classified_as/_/id = 'http://vocab.getty.edu/aat/300404670'">
								<xforms:insert context="instance('object')" nodeset="./child::node()[last()]"
									origin="xforms:element('dcterms:title', (xforms:attribute('xml:lang', 'en'), $content))"/>
							</xforms:action>
							<xforms:action if="context()/classified_as/_/id = 'http://vocab.getty.edu/aat/300312355'">
								<xforms:insert context="instance('object')" nodeset="./child::node()[last()]"
									origin="xforms:element('dcterms:identifier', $content)"/>
							</xforms:action>
						</xforms:action>

						<!-- iterate through types in order to parse the shape -->
						<xforms:action xxforms:iterate="context()/classified_as/_[classified_as/_/id = 'http://vocab.getty.edu/aat/300067209']">
							<xforms:var name="uri" select="context()/id"/>

							<xforms:insert context="instance('object')" nodeset="./child::node()[last()]"
								origin="xforms:element('nmo:hasTypeSeriesItem', (xforms:attribute('rdf:resource', $uri)))"/>
						</xforms:action>

						<!-- insert and convert dimensions to metric -->
						<xforms:action xxforms:iterate="context()/dimension/_">

							<!-- ensure that the value is numeric -->
							<xforms:action if="context()/value castable as xs:decimal">
								<xforms:var name="type" select="data(context()/classified_as/_[1]/id)"/>
								<xforms:var name="value" select="number(context()/value)"/>
								<xforms:var name="units" select="data(context()/unit/id)"/>

								<!-- die axis -->
								<xforms:action if="$type = 'http://nomisma.org/id/axis' and $value castable as xs:integer">

									<!-- the die axis must be between 0 and 12 -->
									<xforms:action if="$value &gt;= 0 and $value &lt;= 12">
										<xforms:insert context="instance('object')" nodeset="./child::node()[last()]"
											origin="xforms:element('nmo:hasAxis', (xforms:attribute('rdf:datatype', 'http://www.w3.org/2001/XMLSchema#integer'), $value))"
										/>
									</xforms:action>

								</xforms:action>

								<!-- weight: grams are required -->
								<xforms:action if="$type = 'http://vocab.getty.edu/aat/300056240' and $units = 'http://vocab.getty.edu/aat/300379225'">
									<xforms:insert context="instance('object')" nodeset="./child::node()[last()]"
										origin="xforms:element('nmo:hasWeight', (xforms:attribute('rdf:datatype', 'http://www.w3.org/2001/XMLSchema#decimal'), $value))"
									/>
								</xforms:action>

								<!-- millimeter-based measurements-->
								<xforms:action
									if="$type = 'http://vocab.getty.edu/aat/300072633' or $type = 'http://vocab.getty.edu/aat/300055624' or $type = 'http://vocab.getty.edu/aat/300055644' or $type = 'http://vocab.getty.edu/aat/300055647'">

									<!-- use AAT URI to determine the correct Nomisma property -->
									<xforms:var name="element"
										select="if ($type = 'http://vocab.getty.edu/aat/300072633') then 'nmo:hasDepth' 
										else if ($type = 'http://vocab.getty.edu/aat/300055624') then 'nmo:hasDiameter' 
										else if ($type = 'http://vocab.getty.edu/aat/300055644') then 'nmo:hasHeight'
										else 'nmo:hasWidth'"/>

									<!-- convert from inches, cm, or leave the mm value. any other $units results in 'null' and the RDF property is not added -->
									<xforms:var name="normalizedValue"
										select="if ($units = 'http://vocab.getty.edu/aat/300379100') then format-number($value * 25.4, '###.##') 
										else if ($units = 'http://vocab.getty.edu/aat/300379098') then format-number($value * 10, '###.##')
										else if ($units = 'http://vocab.getty.edu/aat/300379097') then $value else 'null'"/>

									<xforms:insert context="instance('object')" nodeset="./child::node()[last()]"
										origin="xforms:element($element, (xforms:attribute('rdf:datatype', 'http://www.w3.org/2001/XMLSchema#decimal'), $normalizedValue))"
										if="$normalizedValue castable as xs:decimal"/>
								</xforms:action>

							</xforms:action>
						</xforms:action>

						<!-- boolean variable whether there's a link to a IIIF manifest. The manifest link is required for combined IIIF images (e.g., Harvard Art Museums) -->
						<xforms:var name="hasManifest" select="boolean(context()/subject_of/_[conforms_to/_/id = 'http://iiif.io/api/presentation'])"
							as="xs:boolean"/>

						<!-- digital images -->
						<xforms:action xxforms:iterate="context()//representation">
							<xforms:var name="side"
								select="if (context()/parent::node()/classified_as/_/id = 'http://vocab.getty.edu/aat/300190703') then 'obverse'
								else if (context()/parent::node()/classified_as/_/id = 'http://vocab.getty.edu/aat/300190692') then 'reverse' else 'combined'"/>

							<!-- formulate a different model for combined vs obverse/reverse images -->
							<xforms:action if="$side = 'obverse' or $side = 'reverse'">
								<xforms:var name="element" select="concat('nmo:has', upper-case(substring($side, 1, 1)), substring($side, 2))"/>

								<!-- process IIIF first -->
								<xforms:action if="context()/_[conforms_to = 'http://iiif.io/api/image']">
									<xforms:var name="service" select="context()/_[conforms_to = 'http://iiif.io/api/image']/id"/>

									<!-- create and insert relevant images into nmo:hasObverse and nmo:hasReverse -->
									<xforms:insert context="instance('object')" nodeset="./child::node()[last()]" origin="xforms:element($element)"/>
									<xforms:insert context="instance('object')/*[name()=$element]" origin="xforms:element('rdf:Description')"/>
									<xforms:insert context="instance('object')/*[name()=$element]/rdf:Description" nodeset="./child::node()[last()]"
										origin="xforms:element('foaf:thumbnail', (xforms:attribute('rdf:resource', concat($service, '/full/,120/0/default.jpg')), ''))"/>
									<xforms:insert context="instance('object')/*[name()=$element]/rdf:Description" nodeset="./child::node()[last()]"
										origin="xforms:element('foaf:depiction', (xforms:attribute('rdf:resource', concat($service, '/full/!400,400/0/default.jpg')), ''))"/>


									<!-- insert edm:WebResource and related service templates into instance('rdf') rather than instance('object') -->
									<xforms:insert context="instance('rdf')" nodeset="./child::node()[last()]" origin="instance('webresource-template')"/>
									<xforms:setvalue ref="instance('rdf')/edm:WebResource[last()]/@rdf:about"
										value="concat($service, '/full/!400,400/0/default.jpg')"/>
									<xforms:setvalue ref="instance('rdf')/edm:WebResource[last()]/svcs:has_service/@rdf:resource" value="$service"/>
									<xforms:setvalue ref="instance('rdf')/edm:WebResource[last()]/dcterms:isReferencedBy/@rdf:resource"
										value="concat($service, '/info.json')"/>

									<xforms:insert context="instance('rdf')" nodeset="./child::node()[last()]" origin="instance('service-template')"/>
									<xforms:setvalue ref="instance('rdf')/svcs:Service[last()]/@rdf:about" value="$service"/>
								</xforms:action>

								<xforms:action if="not(context()/_[conforms_to = 'http://iiif.io/api/image'])">

									<!-- only include the property if there's a jpeg image -->
									<xforms:action if="context()/_[format = 'image/jpeg']">
										<xforms:var name="image" select="context()/_[format = 'image/jpeg'][1]/id"/>

										<xforms:insert context="instance('object')" nodeset="./child::node()[last()]" origin="xforms:element($element)"/>
										<xforms:insert context="instance('object')/*[name()=$element]" origin="xforms:element('rdf:Description')"/>
										<xforms:insert context="instance('object')/*[name()=$element]/rdf:Description" nodeset="./child::node()[last()]"
											origin="xforms:element('foaf:depiction', (xforms:attribute('rdf:resource', $image), ''))"/>

									</xforms:action>
								</xforms:action>
							</xforms:action>

							<!-- TODO test later -->
							<xforms:action if="$side = 'combined'">
								<!-- process IIIF first -->
								<xforms:action if="context()/_[conforms_to = 'http://iiif.io/api/image'] and $hasManifest = true()">
									<xforms:var name="service" select="context()/_[conforms_to = 'http://iiif.io/api/image']/id"/>
									<xforms:var name="manifest"
										select="context()/parent::node()/subject_of/_[conforms_to/_/id = 'http://iiif.io/api/presentation']/id"/>

									<!-- insert web resources and service -->

								</xforms:action>
								<xforms:action if="not(context()/_[conforms_to = 'http://iiif.io/api/image'])">
									<xforms:action if="context()/_[format = 'image/jpeg']">
										<xforms:var name="image" select="context()/_[format = 'image/jpeg'][1]/id"/>

										<!-- insert foaf:depiction directly into the nmo:NumismaticObject -->
										<xforms:insert context="instance('object')" nodeset="./child::node()[last()]"
											origin="xforms:element('foaf:depiction', (xforms:attribute('rdf:resource', $image), ''))"/>
									</xforms:action>
								</xforms:action>
							</xforms:action>
						</xforms:action>

						<!-- insert collection link -->
						<xforms:action if="context()/current_owner">
							<xforms:var name="uri" select="data(context()/current_owner/id)"/>
							<xforms:var name="match"
								select="if (instance('mappings')/mapping[@from = $uri]/@to) then instance('mappings')/mapping[@from = $uri]/@to else $uri"/>

							<xforms:insert context="instance('object')" nodeset="./child::node()[last()]"
								origin="xforms:element('nmo:hasCollection', (xforms:attribute('rdf:resource', $match)))"/>
						</xforms:action>

						<!-- insert void:inDataset -->
						<xforms:insert context="instance('object')" nodeset="./child::node()[last()]"
							origin="xforms:element('void:inDataset', (xforms:attribute('rdf:resource', data(instance('void-rdf')/void:Dataset/@rdf:about))))"/>

						<!-- insert HMO template into primary RDF instance after processing -->
						<xforms:insert context="instance('rdf')" nodeset="child::node()[last()]" origin="instance('object')"/>

						<!-- clear template after completion -->
						<xforms:delete nodeset="instance('object')/*"/>
					</xforms:action>
				</xforms:action>
			</xforms:submission>

			<!-- ********** XFORMS-MODEL-CONSTRUCT-DONE ********** -->
			<xforms:action ev:event="xforms-model-construct-done">
				<!-- populate the page with a list of current collections ingested into Nomisma -->
				<xforms:setvalue ref="instance('sparqlQuery')" value="instance('sparql-templates')/query[@id='get-datasets']"/>
				<xforms:send submission="submit-sparqlQuery"/>
				<xforms:delete nodeset="instance('datasets')/*"/>
				<xforms:insert context="instance('datasets')" origin="instance('sparqlResponse')/*"/>
				<!-- insert the list of supplementary datasets bound to named graphs -->
				<!--<xforms:setvalue ref="instance('sparqlQuery')" value="instance('sparql-templates')/query[@id='get-namedGraphs']"/>
				<xforms:send submission="submit-sparqlQuery"/>
				<xforms:action ev:event="xforms-submit-done">
					<xforms:delete nodeset="instance('namedGraphs')/*"/>
					<xforms:insert context="instance('namedGraphs')" origin="instance('sparqlResponse')/*"/>
				</xforms:action>
			</xforms:action>-->
		</xforms:model>
	</head>

	<body>
		<xforms:var name="display_path">../</xforms:var>
		<div class="container-fluid">
			<div class="row">
				<div class="col-md-3 pull-right text-right">
					<h4>
						<a href="logout"><span class="glyphicon glyphicon-log-out"></span> logout</a>
					</h4>
				</div>
			</div>
			<div class="row">
				<div class="col-md-12">
					<p><a href="../"><span class="glyphicon glyphicon-arrow-left"></span>Return to Admin</a></p>
					<xforms:group ref=".[string-length(instance('control-instance')/status) &gt; 0]">
						<div class="alert-success alert alert-box">
							<span class="glyphicon glyphicon-info-sign"></span>
							<strong>Status:</strong>
							<xforms:output ref="instance('control-instance')/status"/>
						</div>
					</xforms:group>
					<h1>Manage Datasets</h1>
					<div>
						<xforms:trigger appearance="minimal">
							<xforms:label><span class="glyphicon glyphicon-plus"></span>Add dataset via RDF/XML VoID</xforms:label>
							<xforms:action ev:event="DOMActivate">
								<!-- reset miscellaneous values -->
								<xforms:setvalue ref="instance('control-instance')/void_uri"/>
								<xforms:setvalue ref="instance('control-instance')/validate-trigger" value="true()"/>
								<xforms:setvalue ref="instance('control-instance')/import-dump-trigger" value="false()"/>

								<xforms:setvalue ref="instance('control-instance')/object_count" value="0"/>
								<xforms:setvalue ref="instance('control-instance')/type_count" value="0"/>
								<xforms:setvalue ref="instance('control-instance')/hoard_count" value="0"/>
								<xforms:setvalue ref="instance('control-instance')/symbol_count" value="0"/>

								<xxforms:show dialog="lookup-dialog"/>
							</xforms:action>
						</xforms:trigger>
						<xforms:trigger appearance="minimal">
							<xforms:label><span class="glyphicon glyphicon-plus"></span>Harvest Linked Art JSON-LD</xforms:label>
							<xforms:action ev:event="DOMActivate">
								<!-- submit SPARQL query to get a list of existing collections to use as dcterms:publisher -->
								<xforms:setvalue ref="instance('sparqlQuery')" value="instance('sparql-templates')/query[@id='get-collections']"/>
								<xforms:send submission="submit-sparqlQuery"/>

								<xforms:action ev:event="xforms-submit-done">
									<xforms:action xxforms:iterate="instance('sparqlResponse')//res:result">
										<xforms:var name="uri" select="data(context()/res:binding[@name='uri']/res:uri)"/>
										<xforms:var name="label" select="data(context()/res:binding[@name='label']/res:literal)"/>

										<xforms:insert context="instance('collections')" nodeset="./child::node()[last()]"
											origin="xforms:element('collection', (xforms:attribute('uri', $uri), $label))"/>
									</xforms:action>

									<!-- toggle interface -->
									<xforms:toggle case="harvest-json"/>
								</xforms:action>
							</xforms:action>
						</xforms:trigger>
					</div>

					<xforms:switch>
						<xforms:case id="default">

							<!--<xforms:trigger>
								<xforms:label>Delete</xforms:label>
								<xforms:action ev:event="DOMActivate">
									<xforms:setvalue ref="instance('control-instance')/dataset">http://localhost:8080/orbeon/igch/</xforms:setvalue>
									<!-\- first delete the objects associated with the dataset, linked by void:inDataset -\->
									<xforms:setvalue ref="instance('sparqlUpdate')"
										value="replace(instance('sparqlUpdate-template')/query[@id='delete-Hoard'], 'DATASET', instance('control-instance')/dataset)"/>
									<xforms:send submission="update-graph"/>
									<!-\- then delete the void:Dataset object -\->
									<xforms:setvalue ref="instance('sparqlUpdate')"
										value="replace(instance('sparqlUpdate-template')/query[@id='delete-metadata'], 'DATASET', instance('control-instance')/dataset)"/>
									<xforms:send submission="update-graph"/>
									<!-\- resubmit SPARQL query for void:Datasets to reset the table -\->
									<xforms:setvalue ref="instance('sparqlQuery')" value="instance('sparql-templates')/query[@id='get-datasets']"/>
									<xforms:send submission="submit-sparqlQuery"/>
									<xforms:delete nodeset="instance('datasets')/*"/>
									<xforms:insert context="instance('datasets')" origin="instance('sparqlResponse')/*"/>
								</xforms:action>
							</xforms:trigger>-->

							<xforms:group ref="instance('datasets')">
								<xforms:group ref=".[count(void:Dataset|*[rdf:type/@rdf:resource = 'http://rdfs.org/ns/void#Dataset']) &gt; 0]">
									<table class="table">
										<thead>
											<tr>
												<th>Dataset</th>
												<th>Publisher</th>
												<th>Record Types</th>
												<!--<th>Refresh</th>-->
												<th>Delete</th>
											</tr>
										</thead>
										<tbody>
											<xforms:repeat nodeset="void:Dataset|*[rdf:type/@rdf:resource = 'http://rdfs.org/ns/void#Dataset']">
												<tr>
													<td>
														<xforms:trigger appearance="minimal">
															<xforms:label value="dcterms:title"/>
															<xforms:action ev:event="DOMActivate">
																<xforms:load show="new" resource="{@rdf:about}"/>
															</xforms:action>
														</xforms:trigger>
													</td>
													<td><xforms:output ref="dcterms:publisher"/></td>
													<td>
														<xforms:repeat
															nodeset="dcterms:type[not(@rdf:resource = 'http://www.w3.org/2004/02/skos/core#Concept')]">
															<xforms:trigger appearance="minimal">
																<xforms:label
																	value="if (contains(@rdf:resource, '#')) then substring-after(@rdf:resource, '#') else tokenize(@rdf:resource, '/')[last()]"/>
																<xforms:action ev:event="DOMActivate">
																	<xforms:load show="new" resource="{@rdf:resource}"/>
																</xforms:action>
															</xforms:trigger>
															<br />
														</xforms:repeat>
													</td>
													<!--<td class="text-center">
														<xforms:trigger appearance="minimal">
															<xforms:label><span class="glyphicon glyphicon-refresh"></span></xforms:label>
															<xforms:action ev:event="DOMActivate">
																<xforms:var name="dataset" select="@rdf:about"/>
																<xforms:var name="type"
																	select="if (dcterms:type[@rdf:resource='http://nomisma.org/ontology#Hoard']) then 'Hoard' else if (dcterms:type[@rdf:resource='http://nomisma.org/ontology#TypeSeriesItem']) then 'TypeSeriesItem' else 'NumismaticObject'"/>
																<xforms:setvalue ref="instance('control-instance')/concept_type" select="$type"/>
																<xforms:setvalue ref="instance('control-instance')/dataset" value="$dataset"/>
																<xforms:dispatch target="refresh-dataset-dialog" name="fr-show"/>
															</xforms:action>
														</xforms:trigger>
													</td>-->
													<td class="text-center">
														<xforms:trigger appearance="minimal">
															<xforms:label><span class="glyphicon glyphicon-remove"></span></xforms:label>
															<xforms:action ev:event="DOMActivate">
																<xforms:var name="dataset" select="@rdf:about"/>
																<!-- the TypeSeriesItem query deletes symbols and monograms -->
																<!--<xforms:var name="type"
																	select="if (dcterms:type[@rdf:resource='http://nomisma.org/ontology#NumismaticObject']) then 'NumismaticObject' 
																		else if (dcterms:type[@rdf:resource='http://nomisma.org/ontology#Hoard']) then 'Hoard' 
																		else 'TypeSeriesItem'"/>
																<xforms:setvalue ref="instance('control-instance')/concept_type" value="$type"/>-->
																<xforms:setvalue ref="instance('control-instance')/dataset" value="$dataset"/>
																<xforms:dispatch target="delete-dataset-dialog" name="fr-show"/>
															</xforms:action>
														</xforms:trigger>
													</td>
												</tr>
											</xforms:repeat>
										</tbody>
									</table>
								</xforms:group>
								<xforms:group ref=".[count(void:Dataset|*[rdf:type/@rdf:resource = 'http://rdfs.org/ns/void#Dataset']) = 0]">
									<p>No datasets found in endpoint. <xforms:trigger appearance="minimal">
											<xforms:label>Add a dataset.</xforms:label>
											<xforms:action ev:event="DOMActivate">
												<xforms:setvalue ref="instance('control-instance')/void_uri"/>
												<xxforms:show dialog="lookup-dialog"/>
											</xforms:action>
										</xforms:trigger></p>
								</xforms:group>

								<xforms:group ref="instance('namedGraphs')[count(*) &gt; 0]">
									<h3>Supplementary Datasets</h3>
									<p>These datasets are bound to named graphs that enable further statements to be made about objects that may already be
										harvested in Nomisma, for example, die links between coins and die URIs that are bound to a named graph defining the
										scholarly attribution.</p>

									<table class="table">
										<thead>
											<tr>
												<th>Dataset</th>
												<th>Publisher</th>
												<th>Type</th>
												<th>Named Graph</th>
												<!--<th>Refresh</th>-->
												<th>Delete</th>
											</tr>
										</thead>
										<tbody>
											<xforms:repeat nodeset="*">
												<tr>
													<td>
														<xforms:trigger appearance="minimal">
															<xforms:label value="dcterms:title"/>
															<xforms:action ev:event="DOMActivate">
																<xforms:load show="new" resource="{@rdf:about}"/>
															</xforms:action>
														</xforms:trigger>
													</td>
													<td><xforms:output ref="dcterms:publisher"/></td>
													<td>
														<xforms:output ref="dcterms:type"/>
													</td>
													<td>
														<xforms:output ref="sd:namedGraph/@rdf:resource"/>
													</td>
													<!--<td class="text-center">
														<xforms:trigger appearance="minimal">
															<xforms:label><span class="glyphicon glyphicon-refresh"></span></xforms:label>
															<xforms:action ev:event="DOMActivate">
																<xforms:var name="dataset" select="@rdf:about"/>
																<xforms:var name="type"
																	select="if (dcterms:type[@rdf:resource='http://nomisma.org/ontology#Hoard']) then 'Hoard' else if (dcterms:type[@rdf:resource='http://nomisma.org/ontology#TypeSeriesItem']) then 'TypeSeriesItem' else 'NumismaticObject'"/>
																<xforms:setvalue ref="instance('control-instance')/concept_type" select="$type"/>
																<xforms:setvalue ref="instance('control-instance')/dataset" value="$dataset"/>
																<xforms:dispatch target="refresh-dataset-dialog" name="fr-show"/>
															</xforms:action>
														</xforms:trigger>
													</td>-->
													<td class="text-center">
														<xforms:trigger appearance="minimal">
															<xforms:label><span class="glyphicon glyphicon-remove"></span></xforms:label>
															<xforms:action ev:event="DOMActivate">
																<xforms:var name="dataset" select="@rdf:about"/>
																<xforms:var name="namedGraph" select="sd:namedGraph/@rdf:resource"/>
																<xforms:setvalue ref="instance('control-instance')/dataset" value="$dataset"/>
																<xforms:setvalue ref="instance('control-instance')/namedGraph" value="$namedGraph"/>
																<xforms:dispatch target="delete-dataset-dialog" name="fr-show"/>
															</xforms:action>
														</xforms:trigger>
													</td>
												</tr>
											</xforms:repeat>
										</tbody>
									</table>
								</xforms:group>
							</xforms:group>
						</xforms:case>
						<xforms:case id="harvest-json">
							<xforms:group ref="instance('void-rdf')/void:Dataset">

								<div class="alert-info alert alert-box">
									<p>
										<span class="glyphicon glyphicon-info-sign"></span>
										<strong>Notice:</strong> This is a beta interface and does not currently update the SPARQL endpoint.</p>
								</div>

								<xforms:group ref=".[not(count(dcterms:title/@xml:lang) = count(distinct-values(dcterms:title/@xml:lang)))]">
									<div class="alert-danger alert alert-box">
										<p>
											<span class="glyphicon glyphicon-exclamation-sign"></span>
											<strong>Alert:</strong> Title languages must be unique.</p>
									</div>
								</xforms:group>

								<xforms:group ref=".[not(count(dcterms:description/@xml:lang) = count(distinct-values(dcterms:description/@xml:lang)))]">
									<div class="alert-danger alert alert-box">
										<p>
											<span class="glyphicon glyphicon-exclamation-sign"></span>
											<strong>Alert:</strong> Description languages must be unique.</p>
									</div>
								</xforms:group>

								<h2>Dataset Metadata</h2>
								<div class="trigger_container">
									<xforms:trigger appearance="minimal">
										<xforms:label>
											<span class="glyphicon glyphicon-plus"></span> Title</xforms:label>
										<xforms:insert ev:event="DOMActivate" context="." nodeset="./child::node()[last()]"
											origin="xforms:element('dcterms:title', (xforms:attribute('xml:lang', '')))"/>
									</xforms:trigger>
									<xforms:trigger appearance="minimal">
										<xforms:label>
											<span class="glyphicon glyphicon-plus"></span> Description</xforms:label>
										<xforms:insert ev:event="DOMActivate" context="." nodeset="./child::node()[last()]"
											origin="xforms:element('dcterms:description', (xforms:attribute('xml:lang', '')))"/>
									</xforms:trigger>
									<xforms:group ref=".[count(dcterms:license) = 0]">
										<xforms:trigger appearance="minimal">
											<xforms:label>
												<span class="glyphicon glyphicon-plus"></span> License</xforms:label>
											<xforms:action ev:event="DOMActivate">
												<xforms:insert context="instance('control-instance')" nodeset="./child::node()[last()]"
													origin="xforms:element('license', '')"/>
												<xforms:insert context="." nodeset="./child::node()[last()]"
													origin="xforms:element('dcterms:license', (xforms:attribute('rdf:resource', '')))"/>
											</xforms:action>

										</xforms:trigger>
									</xforms:group>
									<xforms:group ref=".[count(dcterms:rights) = 0]">
										<xforms:trigger appearance="minimal">
											<xforms:label>
												<span class="glyphicon glyphicon-plus"></span> Rights</xforms:label>
											<xforms:action ev:event="DOMActivate">
												<xforms:insert context="instance('control-instance')" nodeset="./child::node()[last()]"
													origin="xforms:element('rights', '')"/>
												<xforms:insert context="." nodeset="./child::node()[last()]"
													origin="xforms:element('dcterms:rights', (xforms:attribute('rdf:resource', '')))"/>
											</xforms:action>
										</xforms:trigger>
									</xforms:group>
								</div>

								<div>
									<xforms:input ref="@rdf:about">
										<xforms:label>Dataset URI</xforms:label>
									</xforms:input>
								</div>
								<div>
									<xforms:input ref="void:dataDump/@rdf:resource">
										<xforms:label>JSON-LD URL</xforms:label>
									</xforms:input>
								</div>

								<xforms:repeat nodeset="dcterms:title">
									<div>
										<xforms:input ref=".">
											<xforms:label>Title</xforms:label>
											<xforms:alert>Required</xforms:alert>
										</xforms:input>
										<xforms:select1 ref="@xml:lang">
											<xforms:alert>Required</xforms:alert>
											<xforms:item>
												<xforms:label>Select...</xforms:label>
												<xforms:value/>
											</xforms:item>
											<xforms:itemset nodeset="instance('languages')/language">
												<xforms:label ref="."/>
												<xforms:value ref="@value"/>
											</xforms:itemset>
										</xforms:select1>
										<xforms:group ref=".[count(parent::node()/dcterms:title) &gt; 1]">
											<xforms:trigger appearance="minimal">
												<xforms:delete ev:event="DOMActivate" context="."/>
												<xforms:label>
													<span class="glyphicon glyphicon-remove"></span>
												</xforms:label>
											</xforms:trigger>
										</xforms:group>
									</div>
								</xforms:repeat>

								<xforms:repeat nodeset="dcterms:description">
									<div>
										<xforms:textarea ref=".">
											<xforms:label>Description</xforms:label>
											<xforms:alert>Required</xforms:alert>
										</xforms:textarea>
										<xforms:select1 ref="@xml:lang">
											<xforms:alert>Required</xforms:alert>
											<xforms:item>
												<xforms:label>Select...</xforms:label>
												<xforms:value/>
											</xforms:item>
											<xforms:itemset nodeset="instance('languages')/language">
												<xforms:label ref="."/>
												<xforms:value ref="@value"/>
											</xforms:itemset>
										</xforms:select1>
										<xforms:group ref=".[count(parent::node()/dcterms:description) &gt; 1]">
											<xforms:trigger appearance="minimal">
												<xforms:delete ev:event="DOMActivate" context="."/>
												<xforms:label>
													<span class="glyphicon glyphicon-remove"></span>
												</xforms:label>
											</xforms:trigger>
										</xforms:group>
									</div>
								</xforms:repeat>

								<div>
									<xforms:select1 ref="dcterms:publisher/@rdf:resource">
										<xforms:label>Publisher</xforms:label>
										<xforms:alert>Required</xforms:alert>
										<xforms:item>
											<xforms:label>Select...</xforms:label>
											<xforms:value/>
										</xforms:item>
										<xforms:itemset nodeset="instance('collections')/collection">
											<xforms:label ref="."/>
											<xforms:value ref="@uri"/>
										</xforms:itemset>
									</xforms:select1>
								</div>

								<xforms:group ref="instance('control-instance')">

									<xforms:group ref="license">
										<div>

											<xforms:select1 ref=".">
												<xforms:label>License</xforms:label>
												<xforms:alert>Required</xforms:alert>
												<xforms:item>
													<xforms:label>Select...</xforms:label>
													<xforms:value/>
												</xforms:item>
												<xforms:itemset nodeset="instance('licenses')/statement">
													<xforms:label ref="."/>
													<xforms:value ref="@value"/>
												</xforms:itemset>
												<xforms:item>
													<xforms:label>Other License (specify)</xforms:label>
													<xforms:value>other</xforms:value>
												</xforms:item>

												<xforms:action ev:event="xforms-value-changed">
													<xforms:var name="val" select="."/>

													<xforms:action if="starts-with($val, 'http')">
														<xforms:setvalue ref="instance('void-rdf')/void:Dataset/dcterms:license"/>
														<xforms:setvalue ref="instance('void-rdf')/void:Dataset/dcterms:license/@rdf:resource" value="$val"/>

														<xforms:delete nodeset="instance('control-instance')/license/@other"/>
													</xforms:action>
													<xforms:action if="$val = 'other'">
														<xforms:insert context="instance('control-instance')/license" origin="xforms:attribute('other', '')"/>
													</xforms:action>
													<xforms:action if="not(string($val))">
														<!-- blank values -->
														<xforms:setvalue ref="instance('void-rdf')/void:Dataset/dcterms:license"/>
														<xforms:setvalue ref="instance('void-rdf')/void:Dataset/dcterms:license/@rdf:resource"/>

														<xforms:delete nodeset="instance('control-instance')/license/@other"/>
													</xforms:action>
												</xforms:action>
											</xforms:select1>

											<xforms:group ref="@other">
												<div>
													<xforms:textarea ref=".">
														<xforms:label>Other License</xforms:label>
														<xforms:alert>Required</xforms:alert>

														<xforms:action ev:event="xforms-value-changed">
															<xforms:var name="val" select="."/>
															<!-- set the @rdf:resource if the value is a URL, otherwise set the literal -->
															<xforms:action if="matches($val, 'https?://(-\.)?([^\s/?\.#]+\.?)+(/[^\s]*)?$')">
																<!-- insert @rdf:resource if it doesn't already exist -->
																<xforms:insert context="instance('void-rdf')/void:Dataset/dcterms:license"
																	origin="xforms:attribute('rdf:resource', '')"
																	if="not(instance('void-rdf')/void:Dataset/dcterms:license/@rdf:resource)"/>

																<xforms:setvalue ref="instance('void-rdf')/void:Dataset/dcterms:license/@rdf:resource"
																	value="$val"/>
																<xforms:setvalue ref="instance('void-rdf')/void:Dataset/dcterms:license"/>
															</xforms:action>
															<xforms:action if="not(matches($val, 'https?://(-\.)?([^\s/?\.#]+\.?)+(/[^\s]*)?$'))">
																<xforms:delete nodeset="instance('void-rdf')/void:Dataset/dcterms:license/@rdf:resource"/>
																<xforms:setvalue ref="instance('void-rdf')/void:Dataset/dcterms:license" value="$val"/>
															</xforms:action>
														</xforms:action>
													</xforms:textarea>
												</div>
											</xforms:group>

											<!-- allow deletion of license if there's a rights -->
											<xforms:group ref=".[count(instance('void-rdf')/void:Dataset/dcterms:rights) &gt; 0]">
												<xforms:trigger appearance="minimal">
													<xforms:label>
														<span class="glyphicon glyphicon-remove"></span>
													</xforms:label>
													<xforms:action ev:event="DOMActivate">
														<xforms:delete nodeset="."/>
														<xforms:delete nodeset="instance('void-rdf')/void:Dataset/dcterms:license"/>
													</xforms:action>
												</xforms:trigger>
											</xforms:group>
										</div>
									</xforms:group>

									<xforms:group ref="rights">
										<div>

											<xforms:select1 ref=".">
												<xforms:label>Rights</xforms:label>
												<xforms:alert>Required</xforms:alert>
												<xforms:item>
													<xforms:label>Select...</xforms:label>
													<xforms:value/>
												</xforms:item>
												<xforms:itemset nodeset="instance('rights')/statement">
													<xforms:label ref="."/>
													<xforms:value ref="@value"/>
												</xforms:itemset>
												<xforms:item>
													<xforms:label>Other Rights (specify)</xforms:label>
													<xforms:value>other</xforms:value>
												</xforms:item>

												<xforms:action ev:event="xforms-value-changed">
													<xforms:var name="val" select="."/>

													<xforms:action if="starts-with($val, 'http')">
														<xforms:setvalue ref="instance('void-rdf')/void:Dataset/dcterms:rights"/>
														<xforms:setvalue ref="instance('void-rdf')/void:Dataset/dcterms:rights/@rdf:resource" value="$val"/>

														<xforms:delete nodeset="instance('control-instance')/rights/@other"/>
													</xforms:action>
													<xforms:action if="$val = 'other'">
														<xforms:insert context="instance('control-instance')/rights" origin="xforms:attribute('other', '')"/>
													</xforms:action>
													<xforms:action if="not(string($val))">
														<!-- blank values -->
														<xforms:setvalue ref="instance('void-rdf')/void:Dataset/dcterms:rights"/>
														<xforms:setvalue ref="instance('void-rdf')/void:Dataset/dcterms:rights/@rdf:resource"/>

														<xforms:delete nodeset="instance('control-instance')/rights/@other"/>
													</xforms:action>
												</xforms:action>
											</xforms:select1>

											<xforms:group ref="@other">
												<div>
													<xforms:textarea ref=".">
														<xforms:label>Other Rights</xforms:label>
														<xforms:alert>Required</xforms:alert>

														<xforms:action ev:event="xforms-value-changed">
															<xforms:var name="val" select="."/>
															<!-- set the @rdf:resource if the value is a URL, otherwise set the literal -->
															<xforms:action if="matches($val, 'https?://(-\.)?([^\s/?\.#]+\.?)+(/[^\s]*)?$')">
																<!-- insert @rdf:resource if it doesn't already exist -->
																<xforms:insert context="instance('void-rdf')/void:Dataset/dcterms:rights"
																	origin="xforms:attribute('rdf:resource', '')"
																	if="not(instance('void-rdf')/void:Dataset/dcterms:rights/@rdf:resource)"/>

																<xforms:setvalue ref="instance('void-rdf')/void:Dataset/dcterms:rights/@rdf:resource"
																	value="$val"/>
																<xforms:setvalue ref="instance('void-rdf')/void:Dataset/dcterms:rights"/>
															</xforms:action>
															<xforms:action if="not(matches($val, 'https?://(-\.)?([^\s/?\.#]+\.?)+(/[^\s]*)?$'))">
																<xforms:delete nodeset="instance('void-rdf')/void:Dataset/dcterms:rights/@rdf:resource"/>
																<xforms:setvalue ref="instance('void-rdf')/void:Dataset/dcterms:rights" value="$val"/>
															</xforms:action>
														</xforms:action>
													</xforms:textarea>
												</div>
											</xforms:group>

											<!-- allow deletion of rights if there's a license -->
											<xforms:group ref=".[count(instance('void-rdf')/void:Dataset/dcterms:license) &gt; 0]">
												<xforms:trigger appearance="minimal">
													<xforms:label>
														<span class="glyphicon glyphicon-remove"></span>
													</xforms:label>
													<xforms:action ev:event="DOMActivate">
														<xforms:delete nodeset="."/>
														<xforms:delete nodeset="instance('void-rdf')/void:Dataset/dcterms:rights"/>
													</xforms:action>
												</xforms:trigger>
											</xforms:group>
										</div>
									</xforms:group>

								</xforms:group>

								<!-- bind="import-json-trigger" -->
								<xforms:trigger>
									<xforms:label>Begin Harvest</xforms:label>
									<xforms:action ev:event="DOMActivate">
										<xforms:send submission="load-json"/>

										<!-- after the completion of the request, initiate SPARQL publication -->
										<!--<xforms:send submission="post-dump"/>
										<xforms:action ev:event="xforms-submit-done">
										<xforms:insert context="instance('void-rdf')/void:Dataset" nodeset="./child::node()[last()]"
												origin="xforms:element('dcterms:date', current-dateTime())"/>
											<xforms:send submission="post-void"/>
										</xforms:action>-->

										<!-- refresh page after dumps have been posted -->
										<!--<xforms:setvalue ref="instance('sparqlQuery')" value="instance('sparql-templates')/query[@id='get-datasets']"/>
										<xforms:send submission="submit-sparqlQuery"/>
										<xforms:delete nodeset="instance('datasets')/*"/>
										<xforms:insert context="instance('datasets')" origin="instance('sparqlResponse')/*"/>
										<xforms:toggle case="default"/>-->
									</xforms:action>
								</xforms:trigger>
							</xforms:group>
						</xforms:case>
						<xforms:case id="validate-void">
							<xforms:group ref="instance('void-rdf')">
								<xforms:group ref="void:Dataset[@rdf:about]|sd:Dataset[@rdf:about]">
									<!-- display error messages for missing fields -->
									<!--<xforms:group ref=".[not(string(dcterms:title))]">
										<div class="alert-danger alert alert-box">
											<span class="glyphicon glyphicon-exclamation-sign"></span>
											<strong>Alert:</strong> Title is required. </div>
									</xforms:group>-->
									<!--<xforms:group ref=".[not(string(dcterms:description)) and not(dcterms:description[@rdf:resource castable as xs:anyURI])]">
										<div class="alert-danger alert alert-box">
											<span class="glyphicon glyphicon-exclamation-sign"></span>
											<strong>Alert:</strong> Description is required. </div>
									</xforms:group>-->
									<xforms:group ref=".[not(string(dcterms:publisher)) and not(dcterms:publisher[@rdf:resource castable as xs:anyURI])]">
										<div class="alert-danger alert alert-box">
											<span class="glyphicon glyphicon-exclamation-sign"></span>
											<strong>Alert:</strong> Publisher is required. </div>
									</xforms:group>
									<xforms:group ref=".[not(dcterms:license) and not(dcterms:rights)]">
										<div class="alert-danger alert alert-box">
											<span class="glyphicon glyphicon-exclamation-sign"></span>
											<strong>Alert:</strong> License or Rights Statement is required. </div>
									</xforms:group>
									
									<div class="section">
										<div>
											<xforms:output ref="@rdf:about">
												<xforms:label>URI</xforms:label>
												<xforms:alert>Required</xforms:alert>
											</xforms:output>
										</div>
										<xforms:repeat nodeset="dcterms:title">
											<div>
												<xforms:output ref=".">
													<xforms:label>Title</xforms:label>
												</xforms:output>
												<xforms:group ref="@lang">
													<xforms:output value="concat('(', ., ')')"/>
												</xforms:group>
											</div>
										</xforms:repeat>
										<xforms:repeat nodeset="dcterms:description">
											<div>
												<xforms:output value="if (@rdf:resource) then @rdf:resource else .">
													<xforms:label>Description</xforms:label>
												</xforms:output>
												<xforms:group ref="@lang">
													<xforms:output value="concat('(', ., ')')"/>
												</xforms:group>
											</div>
										</xforms:repeat>
										<xforms:group ref="sd:namedGraph">
											<div>
												<div>
													<xforms:output value="sd:NamedGraph/sd:name/@rdf:resource">
														<xforms:label>Named Graph</xforms:label>
													</xforms:output>
												</div>
											</div>
										</xforms:group>
										<xforms:group ref="dcterms:type">
											<div>
												<xforms:output value="if (@rdf:resource) then @rdf:resource else .">
													<xforms:label>Type</xforms:label>
												</xforms:output>
											</div>
										</xforms:group>
										<xforms:group ref="dcterms:publisher">
											<div>
												<xforms:output value="if (@rdf:resource) then @rdf:resource else .">
													<xforms:label>Publisher</xforms:label>
												</xforms:output>
											</div>
										</xforms:group>
										<xforms:group ref="dcterms:license">
											<div>
												<xforms:output value="if (@rdf:resource) then @rdf:resource else .">
													<xforms:label>License</xforms:label>
												</xforms:output>
											</div>
										</xforms:group>
									</div>
									

									<xforms:group ref=".[instance('control-instance')/*[contains(name(), '_count')] &gt; 0]">
										<div class="section">
											<h3>Dataset Evaluation</h3>										
											<xforms:repeat nodeset="instance('control-instance')/*[contains(name(), '_count')]">
												<div>
													<xforms:output ref=".">
														<xforms:label
															value="concat(upper-case(substring(substring-before(name(), '_count'), 1, 1)), substring(substring-before(name(), '_count'), 2), 's')"
														/>
													</xforms:output>
												</div>
											</xforms:repeat>
											<div>
												<xforms:output value="count(instance('places')//crm:E53_Place)">
													<xforms:label>Places</xforms:label>
												</xforms:output>
											</div>
										</div>
									</xforms:group>

									<!-- the validate trigger is only enabled when the VoID RDF metadata conforms to basic requirements -->
									<xforms:trigger bind="validate-trigger">
										<xforms:label><span class="glyphicon glyphicon-check"></span>Validate</xforms:label>

										<!-- iterate through void:dataDumps to evaluate findspot URIs -->
										<xforms:action ev:event="DOMActivate">
											<xforms:setvalue ref="instance('control-instance')/mode">validate</xforms:setvalue>

											<xforms:action xxforms:iterate="instance('void-rdf')/*[local-name()='Dataset']/void:dataDump">
												<xforms:setvalue ref="instance('control-instance')/dump_uri" value="context()/@rdf:resource"/>
												<xforms:send submission="load-dump"/>
											</xforms:action>

											<!-- if there are no errors in the error list, then set validity to true() to enable ingestion -->
											<xforms:action if="count(instance('errors')/error) = 0 and count(instance('warnings')/warning) = 0">
												<xforms:setvalue ref="instance('control-instance')/status">RDF export(s) successfully
													validated.</xforms:setvalue>
												<xforms:setvalue ref="instance('control-instance')/validate-trigger" value="false()"/>
												<xforms:setvalue ref="instance('control-instance')/import-dump-trigger" value="true()"/>
											</xforms:action>

											<!-- if there are errors or warnings, generate the places CSV and toggle the error interface -->
											<xforms:action if="count(instance('errors')/error) &gt; 0 or count(instance('warnings')/warning) &gt; 0">

												<!-- generate the CSV instance of non-matching places to download -->
												<xforms:insert nodeset="instance('csv')"
													origin="xxforms:call-xpl('oxf:/apps/nomisma/xpl/xforms/places-to-csv.xpl', 'data', instance('warnings'), 'data')"/>
												<xforms:setvalue ref="instance('csv-download')"
													value="saxon:string-to-base64Binary(saxon:serialize(instance('csv'), 'text'), 'UTF-8')"/>

												<xforms:toggle case="error-interface"/>
											</xforms:action>

										</xforms:action>
									</xforms:trigger>

									<xforms:trigger bind="import-dump-trigger">
										<xforms:label><span class="glyphicon glyphicon-upload"></span> Import</xforms:label>

										<!-- initiate import of data -->
										<xforms:action ev:event="DOMActivate">
											<!-- set mode for RDF dump submission -->
											<xforms:setvalue ref="instance('control-instance')/mode">import</xforms:setvalue>

											<!-- insert date -->
											<xforms:insert context="instance('void-rdf')/*[local-name()='Dataset']" nodeset="./child::node()[last()]"
												origin="xforms:element('dcterms:date', current-dateTime())"/>

											<!-- push VoID RDF into triplestore -->
											<xforms:send submission="post-void"/>

											<xforms:action ev:event="xforms-submit-done">
												<!-- set the namedGraph, if applicable -->
												<xforms:setvalue ref="instance('control-instance')/namedGraph"
													value="if (instance('void-rdf')/*[local-name()='Dataset']/sd:namedGraph/sd:NamedGraph/sd:name) 
														then instance('void-rdf')/*[local-name()='Dataset']/sd:namedGraph/sd:NamedGraph/sd:name/@rdf:resource 
														else 'default'"/>

												<xforms:action xxforms:iterate="instance('void-rdf')/*[local-name()='Dataset']/void:dataDump">
													<xforms:setvalue ref="instance('control-instance')/dump_uri" value="context()/@rdf:resource"/>
													<xforms:send submission="load-dump"/>

													<!-- delete any hard-coded findspot places or coordinates within the dump (defer to Wikidata API workflow) -->
													<xforms:delete nodeset="instance('rdf')//crm:E53_Place[@rdf:about]"/>
													<xforms:delete nodeset="instance('rdf')//geo:SpatialThing[@rdf:about]"/>
													<xforms:delete nodeset="instance('rdf')//crmgeo:SP5_Geometric_Place_Expression[@rdf:about]"/>

													<xforms:send submission="post-dump"/>
												</xforms:action>

												<!-- send the findspot place hierarchy to the triplestore -->
												<xforms:send submission="post-places" if="count(instance('places')//crm:E53_Place) &gt; 0"/>

												<!-- reset graph to default -->
												<xforms:setvalue ref="instance('control-instance')/namedGraph">default</xforms:setvalue>

												<!-- refresh page after dumps have been posted -->
												<xforms:setvalue ref="instance('sparqlQuery')" value="instance('sparql-templates')/query[@id='get-datasets']"/>
												<xforms:send submission="submit-sparqlQuery"/>
												<xforms:delete nodeset="instance('datasets')/*"/>
												<xforms:insert context="instance('datasets')" origin="instance('sparqlResponse')/*"/>

												<!-- insert the list of supplementary datasets bound to named graphs -->
												<xforms:setvalue ref="instance('sparqlQuery')" value="instance('sparql-templates')/query[@id='get-namedGraphs']"/>
												<xforms:send submission="submit-sparqlQuery"/>
												<xforms:delete nodeset="instance('namedGraphs')/*"/>
												<xforms:insert context="instance('namedGraphs')" origin="instance('sparqlResponse')/*"/>

												<xforms:toggle case="default"/>
											</xforms:action>
										</xforms:action>
									</xforms:trigger>
								</xforms:group>
								<!-- if there is not a void:Dataset child and/or there is no URI for the Dataset, then validation fails outright -->
								<xforms:group ref=".[not(void:Dataset[@rdf:about] or sd:Dataset[@rdf:about])]">
									<div class="alert-danger alert alert-box"><span class="glyphicon glyphicon-exclamation-sign"></span>
										<strong>Alert:</strong> No void:Dataset object or missing dataset URI.</div>
									<xforms:trigger>
										<xforms:label><span class="glyphicon glyphicon-arrow-left"></span> Back</xforms:label>
										<xforms:toggle case="default" ev:event="DOMActivate"/>
									</xforms:trigger>
								</xforms:group>
							</xforms:group>
						</xforms:case>
						<xforms:case id="error-interface">
							<xforms:group ref="instance('warnings')">
								<div class="alert-info alert alert-box"><span class="glyphicon glyphicon-exclamation-sign"></span>
									<strong>Note:</strong> The Manage Places interface does not yet exist.</div>
								
								<xforms:group ref=".[instance('control-instance')/*[contains(name(), '_count')] &gt; 0]">
									<div class="section">
										<h3>Dataset Evaluation</h3>										
										<xforms:repeat nodeset="instance('control-instance')/*[contains(name(), '_count')]">
											<div>
												<xforms:output ref=".">
													<xforms:label
														value="concat(upper-case(substring(substring-before(name(), '_count'), 1, 1)), substring(substring-before(name(), '_count'), 2), 's')"
													/>
												</xforms:output>
											</div>
										</xforms:repeat>
										<div>
											<xforms:output value="count(instance('places')//crm:E53_Place)">
												<xforms:label>Places</xforms:label>
											</xforms:output>
										</div>
									</div>
								</xforms:group>

								<div>
									<h3>Warnings</h3>

									<p>The following place URIs were not resolved to Wikidata Q entities. It is recommended to download the CSV and insert
										reconciled matches into Wikidata prior to ingesting the dataset, as this process is easier than replacing URIs in the
										Manage Places interface.</p>

									<p>If you proceed with the dataset import, points may still appear on maps for these non-Wikidata place entities (if the
										coordinates have been included in the RDF export), but are are not linked to a geographic hierarchy.</p>

									<table class="table">
										<thead>
											<tr>
												<th>Label</th>
												<th>URI</th>
											</tr>
										</thead>
										<tbody>
											<xforms:repeat nodeset="warning">
												<tr>
													<td>
														<xforms:output ref="@label"/>
													</td>
													<td>
														<xforms:trigger appearance="minimal">
															<xforms:label ref="@uri"/>
															<xforms:load ev:event="DOMActivate" show="new" ref="@uri"/>
														</xforms:trigger>
													</td>
												</tr>
											</xforms:repeat>
										</tbody>
									</table>
								</div>
							</xforms:group>

							<div>
								<xforms:trigger appearance="minimal">
									<xforms:label><span class="glyphicon glyphicon-arrow-left"></span> Return to Datasets</xforms:label>
									<xforms:toggle case="default" ev:event="DOMActivate"/>
								</xforms:trigger>


								<xforms:output ref="instance('csv-download')" appearance="xxforms:download">
									<xforms:label><span class="glyphicon glyphicon-download-alt"></span> Download CSV</xforms:label>
									<xforms:mediatype ref="instance('csv-download')/@mediatype"/>
									<xforms:filename ref="instance('csv-download')/@filename"/>
								</xforms:output>

								<xforms:trigger appearance="minimal">
									<xforms:label><span class="glyphicon glyphicon-arrow-right"></span> Proceed with Import</xforms:label>

									<xforms:action ev:event="DOMActivate">
										<xforms:dispatch target="import-dataset-dialog" name="fr-show"/>
									</xforms:action>
								</xforms:trigger>
							</div>
						</xforms:case>
					</xforms:switch>

					<fr:xforms-inspector/>
				</div>
			</div>
		</div>
		<!-- *********** DIALOGS *********** -->
		<!-- this is the dialog for looking up a VoID RDF metadata object -->
		<xxforms:dialog id="lookup-dialog" appearance="full" level="modal" close="true" draggable="true" visible="false">
			<xforms:label>Load VoID RDF</xforms:label>
			<p>Insert the URI for VoID metadata RDF.</p>
			<div>
				<xforms:input ref="instance('control-instance')/void_uri"/>
				<xforms:trigger>
					<xforms:label>Load</xforms:label>
					<!-- delete current options in the instance and initiate new query -->
					<xforms:action ev:event="DOMActivate">						
						<xforms:send submission="load-void"/>
						<xforms:action ev:event="xforms-submit-done">
							<xforms:toggle case="validate-void"/>
							<xforms:setvalue ref="instance('control-instance')/validate-trigger" value="true()" if="xxforms:valid(instance('void-rdf'), true())"
							/>
						</xforms:action>
						<xxforms:hide dialog="lookup-dialog"/>
					</xforms:action>
				</xforms:trigger>
			</div>
		</xxforms:dialog>
		<!-- dialog to confirm deletion of a void:Dataset and associated objects -->
		<fr:alert-dialog id="delete-dataset-dialog">
			<fr:label>Delete Dataset</fr:label>
			<fr:message>Are you sure you want to remove this dataset from the Nomisma.org SPARQL endpoint?</fr:message>
			<fr:positive-choice>
				<fr:label>Yes</fr:label>
				<xforms:action ev:event="DOMActivate">
					<!-- if the namedGraph matches a URI pattern, then execute the DROP GRAPH update -->
					<xforms:action if="matches(instance('control-instance')/namedGraph, '^https?://')">
						<xforms:setvalue ref="instance('sparqlUpdate')"
							value="replace(instance('sparqlUpdate-template')/query[@id = 'delete-namedGraph'], '%GRAPH%', instance('control-instance')/namedGraph)"
						/>
					</xforms:action>
					<!-- if there is no namedGraph, then delete the dataset from the default graph by means of void:inDataset property -->
					<xforms:action if="not(matches(instance('control-instance')/namedGraph, '^https?://'))">
						<!-- be sure to delete multiple types of objects from a single dataset -->
						<xforms:action
							if="instance('datasets')/*[@rdf:about = instance('control-instance')/dataset]/dcterms:type/@rdf:resource = 'http://nomisma.org/ontology#Hoard'">
							<xforms:setvalue ref="instance('sparqlUpdate')"
								value="replace(instance('sparqlUpdate-template')/query[@id = 'delete-Hoard'], 'DATASET', instance('control-instance')/dataset)"/>
							<xforms:send submission="update-graph"/>
						</xforms:action>
						<xforms:action
							if="instance('datasets')/*[@rdf:about = instance('control-instance')/dataset]/dcterms:type/@rdf:resource = 'http://nomisma.org/ontology#TypeSeriesItem'">
							<xforms:setvalue ref="instance('sparqlUpdate')"
								value="replace(instance('sparqlUpdate-template')/query[@id = 'delete-TypeSeriesItem'], 'DATASET', instance('control-instance')/dataset)"/>
							<xforms:send submission="update-graph"/>
						</xforms:action>
						<xforms:action
							if="instance('datasets')/*[@rdf:about = instance('control-instance')/dataset]/dcterms:type/@rdf:resource = 'http://nomisma.org/ontology#NumismaticObject'">
							<xforms:setvalue ref="instance('sparqlUpdate')"
								value="replace(instance('sparqlUpdate-template')/query[@id = 'delete-NumismaticObject'], 'DATASET', instance('control-instance')/dataset)"/>
							<xforms:send submission="update-graph"/>
						</xforms:action>
					</xforms:action>
					<!-- then delete the void:Dataset object -->
					<xforms:setvalue ref="instance('sparqlUpdate')"
						value="replace(instance('sparqlUpdate-template')/query[@id='delete-metadata'], 'DATASET', instance('control-instance')/dataset)"/>
					<xforms:send submission="update-graph"/>
					<!-- resubmit SPARQL query for void:Datasets to reset the table -->
					<xforms:setvalue ref="instance('sparqlQuery')" value="instance('sparql-templates')/query[@id='get-datasets']"/>
					<xforms:send submission="submit-sparqlQuery"/>
					<xforms:delete nodeset="instance('datasets')/*"/>
					<xforms:insert context="instance('datasets')" origin="instance('sparqlResponse')/*"/>
					<!-- insert the list of supplementary datasets bound to named graphs -->
					<xforms:setvalue ref="instance('sparqlQuery')" value="instance('sparql-templates')/query[@id='get-namedGraphs']"/>
					<xforms:send submission="submit-sparqlQuery"/>
					<xforms:delete nodeset="instance('namedGraphs')/*"/>
					<xforms:insert context="instance('namedGraphs')" origin="instance('sparqlResponse')/*"/>
				</xforms:action>
			</fr:positive-choice>
			<fr:negative-choice>
				<fr:label>No</fr:label>
			</fr:negative-choice>
		</fr:alert-dialog>
		<fr:alert-dialog id="import-dataset-dialog">
			<fr:label>Import Dataset</fr:label>
			<fr:message>Are you certain you wish to import this dataset without reconciling outlying places to Wikidata?</fr:message>
			<fr:positive-choice>
				<fr:label>Yes</fr:label>
				<xforms:action ev:event="DOMActivate">
					<!-- set mode for RDF dump submission -->
					<xforms:setvalue ref="instance('control-instance')/mode">import</xforms:setvalue>
					<!-- insert date -->
					<xforms:insert context="instance('void-rdf')/*[local-name()='Dataset']" nodeset="./child::node()[last()]"
						origin="xforms:element('dcterms:date', current-dateTime())"/>
					<!-- push VoID RDF into triplestore -->
					<xforms:send submission="post-void"/> <xforms:action ev:event="xforms-submit-done">
						<!-- set the namedGraph, if applicable -->
						<xforms:setvalue ref="instance('control-instance')/namedGraph"
							value="if (instance('void-rdf')/*[local-name()='Dataset']/sd:namedGraph/sd:NamedGraph/sd:name) 
							then instance('void-rdf')/*[local-name()='Dataset']/sd:namedGraph/sd:NamedGraph/sd:name/@rdf:resource 
							else 'default'"
						/> <xforms:action xxforms:iterate="instance('void-rdf')/*[local-name()='Dataset']/void:dataDump">
							<xforms:setvalue ref="instance('control-instance')/dump_uri" value="context()/@rdf:resource"/>
							<xforms:send submission="load-dump"/>
							<!-- delete any hard-coded findspot places or coordinates within the dump (defer to Wikidata API workflow) -->
							<xforms:delete nodeset="instance('rdf')//crm:E53_Place[@rdf:about]"/>
							<xforms:delete nodeset="instance('rdf')//geo:SpatialThing[@rdf:about]"/>
							<xforms:delete nodeset="instance('rdf')//crmgeo:SP5_Geometric_Place_Expression[@rdf:about]"/> <xforms:send submission="post-dump"/>
						</xforms:action>
						<!-- send the findspot place hierarchy to the triplestore -->
						<xforms:send submission="post-places" if="count(instance('places')//crm:E53_Place) &gt; 0"/>
						<!-- reset graph to default -->
						<xforms:setvalue ref="instance('control-instance')/namedGraph">default</xforms:setvalue>
						<!-- refresh page after dumps have been posted -->
						<xforms:setvalue ref="instance('sparqlQuery')" value="instance('sparql-templates')/query[@id='get-datasets']"/>
						<xforms:send submission="submit-sparqlQuery"/>
						<xforms:delete nodeset="instance('datasets')/*"/>
						<xforms:insert context="instance('datasets')" origin="instance('sparqlResponse')/*"/>
						<!-- insert the list of supplementary datasets bound to named graphs -->
						<xforms:setvalue ref="instance('sparqlQuery')" value="instance('sparql-templates')/query[@id='get-namedGraphs']"/>
						<xforms:send submission="submit-sparqlQuery"/>
						<xforms:delete nodeset="instance('namedGraphs')/*"/>
						<xforms:insert context="instance('namedGraphs')" origin="instance('sparqlResponse')/*"/> <xforms:toggle case="default"/>
					</xforms:action>
				</xforms:action>
			</fr:positive-choice>
			<fr:negative-choice>
				<fr:label>No</fr:label>
			</fr:negative-choice>
		</fr:alert-dialog>
		<!--<fr:alert-dialog id="refresh-dataset-dialog">
			<fr:label>Refresh Dataset</fr:label>
			<fr:message>Refreshing the dataset may take several minutes. Continue?</fr:message>
			<fr:positive-choice>
				<fr:label>Yes</fr:label>
				<xforms:action ev:event="DOMActivate">
					<!-\- first delete the objects associated with the dataset, linked by void:inDataset -\->
					<xforms:setvalue ref="instance('sparqlUpdate')"
						value="replace(instance('sparqlUpdate-template')/query[@id=concat('delete-', instance('control-instance')/concept_type)], 'DATASET', instance('control-instance')/dataset)"/>
					<xforms:send submission="update-graph"/>
					<!-\- then fetch the new data dump -\->
					<xforms:action ev:event="xforms-submit-done">
						<xforms:action xxforms:iterate="instance('sparqlResponse')//void:Dataset[@rdf:about=instance('control-instance')/dataset]/void:dataDump">
							<xforms:setvalue ref="instance('control-instance')/dump_uri" value="context()/@rdf:resource"/>
							<xforms:send submission="load-dump"/>
							<xforms:send submission="post-dump" ev:event="xforms-submit-done"/>
						</xforms:action>
						<!-\- resubmit SPARQL query for void:Datasets to reset the table -\->
						<xforms:setvalue ref="instance('sparqlQuery')" value="instance('sparql-templates')/query[@id='get-datasets']"/>
						<xforms:send submission="submit-sparqlQuery"/>
						<xforms:delete nodeset="instance('datasets')/*"/>
						<xforms:insert context="instance('datasets')" origin="instance('sparqlResponse')/*"/>
					</xforms:action>
				</xforms:action>
			</fr:positive-choice>
			<fr:negative-choice>
				<fr:label>No</fr:label>
			</fr:negative-choice>
		</fr:alert-dialog>-->
	</body>
</html>
